<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>KafkaController的生命周期 | hellolc</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="一、 背景介绍对Kafka了解的同学都知道，KafkaController与状态机犹如Kafka的“大脑”，时刻需要协调着整个Kafka集群的运转。因此它的整体设计是比较复杂的。之前对这块源码了解的也不是非常深入， 刚好前段时间有幸参与研发Kafka的Zookeeper迁移项目，借此机会对KafkaController与状态机的源码有了更深入的了解。 同时把这次的收获记录下来，结合线上遇到的真实案">
<meta name="keywords" content="kafka">
<meta property="og:type" content="article">
<meta property="og:title" content="KafkaController的生命周期">
<meta property="og:url" content="http://blog.hellolc.com/2022/02/20/KafkaController的生命周期/index.html">
<meta property="og:site_name" content="hellolc">
<meta property="og:description" content="一、 背景介绍对Kafka了解的同学都知道，KafkaController与状态机犹如Kafka的“大脑”，时刻需要协调着整个Kafka集群的运转。因此它的整体设计是比较复杂的。之前对这块源码了解的也不是非常深入， 刚好前段时间有幸参与研发Kafka的Zookeeper迁移项目，借此机会对KafkaController与状态机的源码有了更深入的了解。 同时把这次的收获记录下来，结合线上遇到的真实案">
<meta property="og:image" content="https://img.alicdn.com/imgextra/i3/O1CN01V8iRwS1h3ixv8xMzk_!!6000000004222-2-tps-2924-1344.png">
<meta property="og:image" content="https://img.alicdn.com/imgextra/i3/O1CN01KVhOzU20ZIyWUvTL1_!!6000000006863-2-tps-1500-1011.png">
<meta property="og:image" content="https://img.alicdn.com/imgextra/i4/O1CN01ydLbsV25GasDXxa9h_!!6000000007499-2-tps-1500-666.png">
<meta property="og:image" content="https://img.alicdn.com/imgextra/i1/O1CN01w2IQiV1cBtxSzqTpW_!!6000000003563-2-tps-1500-890.png">
<meta property="og:image" content="https://img.alicdn.com/imgextra/i3/O1CN01cKibQn20zrwcnZ2ke_!!6000000006921-2-tps-1500-1188.png">
<meta property="og:image" content="https://img.alicdn.com/imgextra/i3/O1CN01UiNdfe1ycqoIrT1WX_!!6000000006600-2-tps-760-208.png">
<meta property="og:image" content="https://img.alicdn.com/imgextra/i4/O1CN01BBZT4C1NwPwklgeJf_!!6000000001634-2-tps-1500-600.png">
<meta property="og:image" content="https://img.alicdn.com/imgextra/i1/O1CN01hV4Qtp27dc0m8Q8Oo_!!6000000007820-2-tps-1500-445.png">
<meta property="og:image" content="https://img.alicdn.com/imgextra/i2/O1CN01SgQXRg1ebfTNIveDz_!!6000000003890-2-tps-1322-202.png">
<meta property="og:image" content="https://img.alicdn.com/imgextra/i1/O1CN01prPy4o1GVD6sR4wzf_!!6000000000627-2-tps-1500-304.png">
<meta property="og:image" content="https://img.alicdn.com/imgextra/i3/O1CN01pM1E901NrNajNO3uR_!!6000000001623-2-tps-880-132.png">
<meta property="og:image" content="https://img.alicdn.com/imgextra/i2/O1CN017sdDrk1rrmPSryAdY_!!6000000005685-2-tps-1324-352.png">
<meta property="og:image" content="https://img.alicdn.com/imgextra/i3/O1CN01zzKJYC1wPuO8yNVBq_!!6000000006301-2-tps-638-280.png">
<meta property="og:image" content="https://img.alicdn.com/imgextra/i1/O1CN01OCO21c1O8KFDAQ90b_!!6000000001660-2-tps-1338-146.png">
<meta property="og:image" content="https://img.alicdn.com/imgextra/i1/O1CN01XoCxuQ27ardMlbSyz_!!6000000007814-2-tps-1500-877.png">
<meta property="og:image" content="https://img.alicdn.com/imgextra/i3/O1CN01f5Bq7C1aGoyjZ3uP1_!!6000000003303-2-tps-1500-79.png">
<meta property="og:image" content="https://img.alicdn.com/imgextra/i2/O1CN01rtul6Y1rHb7XCMkzu_!!6000000005606-2-tps-1500-472.png">
<meta property="og:image" content="https://img.alicdn.com/imgextra/i3/O1CN01PxbvjF1YYZ5t4sABm_!!6000000003071-2-tps-1500-135.png">
<meta property="og:image" content="https://img.alicdn.com/imgextra/i3/O1CN01qRsiOS1fqc0oEghPu_!!6000000004058-2-tps-1500-1377.png">
<meta property="og:image" content="https://img.alicdn.com/imgextra/i3/O1CN01N6kCdF1FbKn7AHmd7_!!6000000000505-2-tps-1150-610.png">
<meta property="og:image" content="https://img.alicdn.com/imgextra/i1/O1CN01OKN9WQ1GiwzStFaPL_!!6000000000657-2-tps-1188-252.png">
<meta property="og:image" content="https://img.alicdn.com/imgextra/i3/O1CN01hG8P3a1brkWzvGTik_!!6000000003519-2-tps-1500-959.png">
<meta property="og:image" content="https://img.alicdn.com/imgextra/i3/O1CN01g9jx3j1oTYcL6ClhQ_!!6000000005226-2-tps-1500-564.png">
<meta property="og:image" content="https://img.alicdn.com/imgextra/i1/O1CN01VL3esj1Qhi4nBEu8F_!!6000000002008-2-tps-1500-663.png">
<meta property="og:image" content="https://img.alicdn.com/imgextra/i2/O1CN01eJ8JFt1REgapVtVDM_!!6000000002080-2-tps-948-182.png">
<meta property="og:image" content="https://img.alicdn.com/imgextra/i2/O1CN0155Wlsf1UGSyqo36IG_!!6000000002490-2-tps-1500-598.png">
<meta property="og:image" content="https://img.alicdn.com/imgextra/i2/O1CN01unc1BF1CAp0xRof1T_!!6000000000041-2-tps-1500-580.png">
<meta property="og:image" content="https://img.alicdn.com/imgextra/i4/O1CN015Wi9OY1dWLFcIRdre_!!6000000003743-2-tps-1500-439.png">
<meta property="og:image" content="https://img.alicdn.com/imgextra/i1/O1CN01A7y9th1Z2Kq6aHRab_!!6000000003136-2-tps-1500-678.png">
<meta property="og:image" content="https://img.alicdn.com/imgextra/i1/O1CN01DlgF4t1tdF4JhPKhM_!!6000000005924-2-tps-1500-384.png">
<meta property="og:image" content="https://img.alicdn.com/imgextra/i3/O1CN01jZB1yk1Gn4YekSH7G_!!6000000000666-2-tps-1426-634.png">
<meta property="og:image" content="https://img.alicdn.com/imgextra/i2/O1CN01NUt6ah1K3y0rVOAxI_!!6000000001109-2-tps-1384-508.png">
<meta property="og:image" content="https://img.alicdn.com/imgextra/i4/O1CN01Q9VbbD1CBHPcKSCsh_!!6000000000042-2-tps-1500-304.png">
<meta property="og:image" content="https://img.alicdn.com/imgextra/i3/O1CN01gYkGcN1cFZ7x2GD6i_!!6000000003571-2-tps-1494-980.png">
<meta property="og:image" content="https://img.alicdn.com/imgextra/i1/O1CN016rnPKj1go9UrZwksi_!!6000000004188-2-tps-1782-611.png">
<meta property="og:image" content="https://img.alicdn.com/imgextra/i3/O1CN01bkl04P1OzSBu38lvO_!!6000000001776-2-tps-1500-959.png">
<meta property="og:updated_time" content="2022-08-29T03:11:32.154Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="KafkaController的生命周期">
<meta name="twitter:description" content="一、 背景介绍对Kafka了解的同学都知道，KafkaController与状态机犹如Kafka的“大脑”，时刻需要协调着整个Kafka集群的运转。因此它的整体设计是比较复杂的。之前对这块源码了解的也不是非常深入， 刚好前段时间有幸参与研发Kafka的Zookeeper迁移项目，借此机会对KafkaController与状态机的源码有了更深入的了解。 同时把这次的收获记录下来，结合线上遇到的真实案">
<meta name="twitter:image" content="https://img.alicdn.com/imgextra/i3/O1CN01V8iRwS1h3ixv8xMzk_!!6000000004222-2-tps-2924-1344.png">
  
    <link rel="alternate" href="/atom.xml" title="hellolc" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">hellolc</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://blog.hellolc.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-KafkaController的生命周期" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/02/20/KafkaController的生命周期/" class="article-date">
  <time datetime="2022-02-20T15:11:52.000Z" itemprop="datePublished">2022-02-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      KafkaController的生命周期
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="一、-背景介绍"><a href="#一、-背景介绍" class="headerlink" title="一、 背景介绍"></a>一、 背景介绍</h1><p>对Kafka了解的同学都知道，KafkaController与状态机犹如Kafka的“大脑”，时刻需要协调着整个Kafka集群的运转。因此它的整体设计是比较复杂的。之前对这块源码了解的也不是非常深入， 刚好前段时间有幸参与研发Kafka的Zookeeper迁移项目，借此机会对KafkaController与状态机的源码有了更深入的了解。 同时把这次的收获记录下来，结合线上遇到的真实案例与大家一起学习分享。<br>此次源码解析系列主要分成两部分。 第一部分主要依照KafkaV2.6版本的核心源码，简单介绍KafkaController与状态机的逻辑； 第二部分对照现有的KafkaController与状态机逻辑，简单介绍一下Kafka最新版3.2版本的KRaft状态机机制。<br>整体内容比较多， 会不定期更新。</p>
<h1 id="二、-KafkaController"><a href="#二、-KafkaController" class="headerlink" title="二、 KafkaController"></a>二、 KafkaController</h1><h2 id="2-1-基础功能"><a href="#2-1-基础功能" class="headerlink" title="2.1 基础功能"></a><strong>2.1 基础功能</strong></h2><p>KafkaController它的主要功能是做什么的呢？顾名思义， 我们大概能猜出<strong>KafkaController是Kafka集群的协调者</strong>，他的主要工作是根据各broker节点的存活状态来<strong>协调管理集群中的分区和副本的状态</strong>。<br>举个例子，假设一个kafka集群， 拥有3个Broker节点， 同时创建一个topic叫topicA，它有1个分区， 每个分区存在3个副本。 在Controller的分配协调下，最终3个副本会被分配给各个Broker节点， 同时101上的副本被选为副本leader， 然后其他副本会启动额外线程定期从leader副本上拉取复制数据。<br><img src="https://img.alicdn.com/imgextra/i3/O1CN01V8iRwS1h3ixv8xMzk_!!6000000004222-2-tps-2924-1344.png" alt=""><br>上面了解了一下Controller的一项基本工作，此时候你是不是会有很多疑问？3个副本是是怎么分配的？为什么101的副本作为leader？ 101宕机了怎么办？ 等等问题。。。回答这些问题前， 我们先弄清楚谁是Controller。</p>
<h2 id="2-2-组件架构图"><a href="#2-2-组件架构图" class="headerlink" title="2.2 组件架构图"></a><strong>2.2 组件架构图</strong></h2><p>首先我们通过一张组件架构图， 简单的了解一下KafkaController的组件架构全貌， 后续我们也会围绕这些组件和大家介绍KafkaController的相关源码。<br><img src="https://img.alicdn.com/imgextra/i3/O1CN01KVhOzU20ZIyWUvTL1_!!6000000006863-2-tps-1500-1011.png" alt=""></p>
<h2 id="2-3-竞选-Controller"><a href="#2-3-竞选-Controller" class="headerlink" title="2.3 竞选 Controller"></a><strong>2.3 竞选 Controller</strong></h2><p>继续上面的问题， Kafka的Controller是谁呢？ 可以告诉大家的是， <strong>Kafka的Controller是由自身的计算节点来充当的</strong>， 也就是说上面例子中， 101-103都是潜在的Controller。<br>那大家都有机会成为Controller， 那又是如何确定谁是Controller的呢？<br>这时候就需要提到Kafka额外依赖的组件 Zookeeper（<a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-500%3A+Replace+ZooKeeper+with+a+Self-Managed+Metadata+Quorum" target="_blank" rel="noopener">KRaft架构可不再依赖</a>）。<br>各个节点连接Zookeeper集群后，向<strong>/controller</strong>创建一个<strong>EPHEMERAL类型的ZK节点</strong>，一旦某个节点创建成功，那么这个节点就会被选为集群的Controller，后续来创建的节点都会失败， 但他们会监听这个节点的生命周期变化， 一旦发现这个节点被删除， 各个节点又会开始尝试创建， 以此来保证时刻有Controller存在。</p>
<p>EPHEMERAL类型的意思是： 这个节点的生命周期与这次的zookeeper连接的生命周期息息相关， 当此次的session连接断开时，被Zookeeper服务端检测到， 就会将这个节点删除</p>
<h3 id="2-3-1-ControllerEventManager"><a href="#2-3-1-ControllerEventManager" class="headerlink" title="2.3.1 ControllerEventManager"></a><strong>2.3.1 ControllerEventManager</strong></h3><p>接下里我们看下源码是如何实现的。<br><img src="https://img.alicdn.com/imgextra/i4/O1CN01ydLbsV25GasDXxa9h_!!6000000007499-2-tps-1500-666.png" alt=""><br>为了方便演示，部分示例中的代码会删除一些非核心逻辑，后续不再提示。</p>
<p>首先， 我们看到当KafkaServer启动后， 初始化kafkaController对象并调用其startup方法， startup方法里主要做的事情如下， 首先在zkClient上注册一个stateChagnehandler了， 这个我们稍微再讲， 我们先讲<strong>EventManager</strong>， 我们看到它向eventManager队列里插入了一个Startup类， 同时调用start启动eventManager。<br>顾名思义， EventManager是一个事件管理中心, 后续KafkaController相关事件处理， 都会被放到这里进行处理，他的实现也比较简单，就一个线程不停的从阻塞队列里拉取新进来的事件， 然后进行处理。<br><strong>他的主要作用如下：</strong></p>
<ol>
<li>所有事件统一管控， 当发生controller发生切换后，<strong> 可立即清除未处理完的消息， 避免产生脏数据</strong>；</li>
<li>所有事件异步化处理， 同时所有事件按<strong>顺序执行，不存在并发问题</strong>；</li>
</ol>
<p><img src="https://img.alicdn.com/imgextra/i1/O1CN01w2IQiV1cBtxSzqTpW_!!6000000003563-2-tps-1500-890.png" alt=""><br><img src="https://img.alicdn.com/imgextra/i3/O1CN01cKibQn20zrwcnZ2ke_!!6000000006921-2-tps-1500-1188.png" alt=""><br><img src="https://img.alicdn.com/imgextra/i3/O1CN01UiNdfe1ycqoIrT1WX_!!6000000006600-2-tps-760-208.png" alt=""><br>当eventManager 执行到<strong>processStartup</strong>对应的事件时, 方法里面的内容也很简单， 就做了两件事， <strong>会触发elect进行Controller选举</strong>（<strong>registerZNodeChangeHandlerAndCheckExistence</strong>这个我们稍微再讲，大家先记住这个方法）， 具体逻辑我们进一步看下。</p>
<h3 id="2-3-2-选举核心逻辑"><a href="#2-3-2-选举核心逻辑" class="headerlink" title="2.3.2 选举核心逻辑"></a><strong>2.3.2 选举核心逻辑</strong></h3><p><img src="https://img.alicdn.com/imgextra/i4/O1CN01BBZT4C1NwPwklgeJf_!!6000000001634-2-tps-1500-600.png" alt=""><br><img src="https://img.alicdn.com/imgextra/i1/O1CN01hV4Qtp27dc0m8Q8Oo_!!6000000007820-2-tps-1500-445.png" alt=""><br>选举逻辑也非常清晰</p>
<ol>
<li>先从zk节点上查询<strong>/controller</strong>节点的值 ；</li>
<li>如果存在，说明有其他节点已经提前成为Controller了， 则直接退出；</li>
<li>如果不存在， 则先创建/controller类型为EPHEMERAL, 如果成功，再将/controller_epoch 递增+1；</li>
<li>如果创建成功， 则会将<strong>controller_epoch和epochZkVersion 记录下来， 这两个值比较重要， 大家先记住</strong>， 后面会说明它的作用；</li>
<li>最后执行<strong>onControllerFailover</strong>，开始成为Controller的一些初始化操作， 这块比较复杂， 我们后面单独来讲；</li>
</ol>
<p>controller_epoch 是用来表示controller更新到哪一代了， 也就是一旦controller变化一次， controler_epoch就会递增+1， 这个值在后面用途非常重要， 大家重视一下；</p>
<p>epochZkVersion 是controller_epoch在zk节点上的dataVersion， 也就是说/controller_epoch节点每更新一次也会递增一次， 一般情况下此值和controller_epoch的一样的， 这个值在后面用途非常重要， 大家重视一下；</p>
<h3 id="2-3-3-选举问题"><a href="#2-3-3-选举问题" class="headerlink" title="2.3.3 选举问题"></a><strong>2.3.3 选举问题</strong></h3><p>整体逻辑看起来不是非常复杂， 但大家有没有如下疑问：<br>假设controller节点创建成功， 但由于某些原因（比如网络抖动），导致修改controller_epoch失败了，会怎么样？</p>
<p>我们看上面代码， kafka使用了<strong>Zookeeper的multi的api</strong>， 这个api有什么特性呢？<br>当任何一步操作失败了，都会导致之前的操作回滚，zookeeper的事务功能就是使用这个来实现的。</p>
<p><strong>因此当controller_epoch修改失败， 也会导致此次竞选controller失败。</strong><br>一旦elect竞选成功， KafkaController<strong>就开始触发failover进行初始化</strong>。failover的逻辑比较多，我们稍后单独来讲， 我们先把Controller完整生命周期讲完。接下来我们讲下卸载Controller相关的逻辑。</p>
<h2 id="2-4-卸任-Controller"><a href="#2-4-卸任-Controller" class="headerlink" title="2.4 卸任 Controller"></a><strong>2.4 卸任 Controller</strong></h2><p>卸任Controller的方式，主要分为两种：</p>
<ol>
<li>一种是<strong>主动触发：删除zookeeper的/controller节点触发；</strong></li>
<li>一种是<strong>被动触发： zookeeper的session过期触发；</strong></li>
</ol>
<p>当KafkaController卸任时， 就会触发新一轮Controller竞选。 那这里就有几个问题：</p>
<ol>
<li>当前的KafkaController是怎么知道自己要进行“退休并办理交接手续”的呢？</li>
<li><p>其他节点是怎么知道Controller已经退位， 要开始新一轮竞选Controller的呢？</p>
<h3 id="2-4-1-主动触发"><a href="#2-4-1-主动触发" class="headerlink" title="2.4.1 主动触发"></a><strong>2.4.1 主动触发</strong></h3><p>带着上面两个问题， 我们回到源码找答案。<br><img src="https://img.alicdn.com/imgextra/i2/O1CN01SgQXRg1ebfTNIveDz_!!6000000003890-2-tps-1322-202.png" alt=""><br><img src="https://img.alicdn.com/imgextra/i1/O1CN01prPy4o1GVD6sR4wzf_!!6000000000627-2-tps-1500-304.png" alt=""><br>刚刚我们研究<strong>processStartup</strong>方法时， 我们忽略了一下方法 <strong>registerZNodeChangeHandlerAndCheckExistence</strong>，它的<strong>作用就是在zookeeper上注册监听/controller的生命周期</strong>，同时传递进去<strong>ControllerChangeHandler回调对象</strong>， 当/controller的生命周期一旦发生变化， 就会回调ControllerChangeHandler对象里对应的方法，然后把需要做的事情放到我们上面讲过的Eventmanger对象里异步执行。<br>其实<strong>ControllerChangeHandler</strong>对象里做的事情也比较简单:</p>
</li>
<li><p>当/controller节点被主动删除时， 就触发elect竞选逻辑， 就是我们上面讲得竞选逻辑。</p>
</li>
<li>当/controller节点被创建或者数据发生改变时， 就判断自己还是不是KafkaController， 如果不是了就调用onControllerResignation卸任Controller。 onControllerResignation的逻辑我们后面再讲。</li>
</ol>
<p><img src="https://img.alicdn.com/imgextra/i3/O1CN01pM1E901NrNajNO3uR_!!6000000001623-2-tps-880-132.png" alt=""><br><img src="https://img.alicdn.com/imgextra/i2/O1CN017sdDrk1rrmPSryAdY_!!6000000005685-2-tps-1324-352.png" alt=""></p>
<h4 id="Zookeeper监听机制"><a href="#Zookeeper监听机制" class="headerlink" title="Zookeeper监听机制"></a><strong>Zookeeper监听机制</strong></h4><p>注意一个细节， 在上面的<strong>maybeResign</strong>方法里， 我们发现程序又调用了一次<strong>registerZNodeChangeHandlerAndCheckExistence</strong>，在zookeeper再次注册监听，那么问题来了， 当zookeeper发生相应事件时， 会不会被<strong>多次调用</strong>呢？这肯定不是我们预期的， 那么KafkaController是如何避免这类问题呢？<br><img src="https://img.alicdn.com/imgextra/i3/O1CN01zzKJYC1wPuO8yNVBq_!!6000000006301-2-tps-638-280.png" alt=""><br><img src="https://img.alicdn.com/imgextra/i1/O1CN01OCO21c1O8KFDAQ90b_!!6000000001660-2-tps-1338-146.png" alt=""><br>我们看到kafka不是直接在zookeeper上注册对应事件的， 而是内部维护了一个叫<strong>zNodeChangeHandlers</strong>的map对象， 他的key为ZNodeChangeHandler接口的path， value为具体的ZNodeChangeHandler对象。在回到上面看ControllerChangeHandler对象， 它是实现了ZNodeChangeHandler接口， 因此它的key就是ControllerZNode.path， 也就是/controller，<strong>因此多次注册， 也会以最后一次调用为准。</strong><br>那它又是如何与zookeeper关联起来的呢？<br><img src="https://img.alicdn.com/imgextra/i1/O1CN01XoCxuQ27ardMlbSyz_!!6000000007814-2-tps-1500-877.png" alt=""><br><img src="https://img.alicdn.com/imgextra/i3/O1CN01f5Bq7C1aGoyjZ3uP1_!!6000000003303-2-tps-1500-79.png" alt=""><br><img src="https://img.alicdn.com/imgextra/i2/O1CN01rtul6Y1rHb7XCMkzu_!!6000000005606-2-tps-1500-472.png" alt=""><br><img src="https://img.alicdn.com/imgextra/i3/O1CN01PxbvjF1YYZ5t4sABm_!!6000000003071-2-tps-1500-135.png" alt=""><br>Kafka这块实现还是比较精巧， 它在<strong>初始化zookeeper对象时</strong>，传递进去一个叫<strong>ZooKeeperClientWatcher</strong>对象， <strong>后续所有监听事件都由这个对象统一管理，这样减小了代码的复杂度和额外的内存开销。</strong><br>然后在调用exists、getData、getChildren时，判断<strong>zNodeChangeHandlers或zNodeChildChangeHandlers</strong>这2个map对象里是否有对应的key， 来决定是否监听对应zookeeper节点的生命周期变化。<br>当zookeeper发生监听的事件时，在从zNodeChangeHandlers或zNodeChildChangeHandlers的map对象上判断这个key是否存在， 存在就调用相应方法。<br>以上这些设计， 就大大降低了监听事件的整体复杂度。</p>
<p>zNodeChildChangeHandlers 是用来监听zookeeper节点的子节点数量变化情况</p>
<h4 id="整体调用链路"><a href="#整体调用链路" class="headerlink" title="整体调用链路"></a><strong>整体调用链路</strong></h4><p>至此Controller的整体调用链路我们已经非常清楚了， 就是ZookeeperWatch触发调用各种监听Handlers，然后放入ControllerEventManager的队列里， 按进队顺序执行，最后操作zk或者改变状态机。<br><img src="https://img.alicdn.com/imgextra/i3/O1CN01qRsiOS1fqc0oEghPu_!!6000000004058-2-tps-1500-1377.png" alt=""></p>
<h3 id="2-4-2-被动触发"><a href="#2-4-2-被动触发" class="headerlink" title="2.4.2 被动触发"></a><strong>2.4.2 被动触发</strong></h3><p>上面讲了当/controller节点被主动删除而引起的卸任。那么被动触发是怎么引起的？<br>一般情况下，是由于<strong>网络抖动</strong>， zookeeper的客户端在规定的时间内（<a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-537%3A+Increase+default+zookeeper+session+timeout" target="_blank" rel="noopener">V2.5以前的版本默认为6s，V2.5后的版本18s</a>）未向服务端成功发送<strong>心跳</strong>，当网络恢复后，客户端再次向服务端发送心跳时，服务端会判断此客户端<strong>session已过期</strong>， 会向客户端发送<strong>session expired 事件</strong>。最终会调用<strong>reinitialize</strong>方法。<br><img src="https://img.alicdn.com/imgextra/i3/O1CN01N6kCdF1FbKn7AHmd7_!!6000000000505-2-tps-1150-610.png" alt=""><br><img src="https://img.alicdn.com/imgextra/i1/O1CN01OKN9WQ1GiwzStFaPL_!!6000000000657-2-tps-1188-252.png" alt=""><br><img src="https://img.alicdn.com/imgextra/i3/O1CN01hG8P3a1brkWzvGTik_!!6000000003519-2-tps-1500-959.png" alt=""><br><img src="https://img.alicdn.com/imgextra/i3/O1CN01g9jx3j1oTYcL6ClhQ_!!6000000005226-2-tps-1500-564.png" alt=""><br>查看<strong>reinitialize</strong>方法， 我们发现它会回调<strong>stateChangeHandlers</strong>的方法， 这是什么东西呢？<br>我们把代码回到前面我们讲过得<strong>KafkaController.startup</strong>的地方，KafkaController类刚启动的时候会注册这个<strong>stateChangeHandler</strong>。<br><img src="https://img.alicdn.com/imgextra/i1/O1CN01VL3esj1Qhi4nBEu8F_!!6000000002008-2-tps-1500-663.png" alt=""><br>因此reinitialize方法， 会调调用这个state的<strong>beforeInitializingSession</strong>方法， 也就是先把未执行的任务清楚掉，再把<strong>Expire</strong>类放入eventManager里进行调用， 并且阻塞线程， 直到Expire执行完毕。<br>Expire逻辑也非常简单， 就是调用<strong>onControllerResignation</strong>, 进行卸任Controller。<br><img src="https://img.alicdn.com/imgextra/i2/O1CN01eJ8JFt1REgapVtVDM_!!6000000002080-2-tps-948-182.png" alt=""><br>卸任完毕后， 会初始一个新的Zookeeper对象，然后回调<strong>afterInitializingSession</strong>方法。<br><strong>afterInitializingSession</strong>里面方法逻辑也非常简单:</p>
<ol>
<li>因为之前的zookeeper已经session过期， 所以需要<strong>重新创建/brokers/ids/[101,102,103], 告知Controler自己的存在</strong>；</li>
<li><strong>processReelect</strong>操作，就是<strong>挂载监听/controller节点变化</strong>，同时尝试竞选KafkaController， 和之前的逻辑基本一样， 这里不再复述；</li>
</ol>
<p>/brokers/ids/xxx 这个节点和/controller节点一样，都是EPHEMERAL类型节点， 它的生命周期和broker节点的生命周期一样， 也就是说broker节点宕机这个节点就会被删除; 节点上线， 这个节点就会被创建，KafkaController也通过这个zookeeper节点来判断对应的broker节点是否存活</p>
<h4 id="Session-过期问题"><a href="#Session-过期问题" class="headerlink" title="Session 过期问题"></a><strong>Session 过期问题</strong></h4><p><strong>注册/brokers/ids</strong> 这里会有个<strong>session过期问题</strong>需要说下。就是当创建/brokers/ids/[101,102,103] 这个节点时，发现节点还存在，kafka会这么做？<br>我们先来看下<strong>0.10.2版本</strong>的逻辑。<br><img src="https://img.alicdn.com/imgextra/i2/O1CN0155Wlsf1UGSyqo36IG_!!6000000002490-2-tps-1500-598.png" alt=""><br>0.10.2版本， 发现节点存在， <strong>就会直接抛出异常</strong>， 不再做其他事情了。大家先想想这样做是否合理？<br>看到这里， 大家会有疑问，刚上面说了这个节点是EPHEMERAL节点，也就说，刚刚zookeeper客户端重新初始化了， 之前的sessionId应该已经过期了， 那么对应的节点应该被删除了， 为何还存在呢？<br>一般情况下，是不会出现上面的问题的， 但当一个大zookeeper集群的网络出现问题时， 就有可能出现上面这问题， <strong>当网络出现问题时， 整个集群的客户端都因为心跳不可达而过期，但是由于集群过期的节点非常多， zookeeper服务端还没来得及删除所有的过期节点时， 网络恢复了， 然后此时去创建这个节点， 就会发现这个节点存在</strong>。过了一会， 这个节点就会被zookeeper删除， 但由于<strong>sessionId不一样， broker是无法感知到的，那么就会有可能导致各节点的metadata信息不一致的问题。</strong></p>
<p>我们之前就遇到过ZK网络抖动导致的这类问题，所有还在用0.10.2版本的同学尽快升级了。</p>
<p>我们再来看下<strong>2.x的版本</strong>是如何实现的。</p>
<p><img src="https://img.alicdn.com/imgextra/i2/O1CN01unc1BF1CAp0xRof1T_!!6000000000041-2-tps-1500-580.png" alt=""><br><img src="https://img.alicdn.com/imgextra/i4/O1CN015Wi9OY1dWLFcIRdre_!!6000000003743-2-tps-1500-439.png" alt=""><br>2.x的版本这块逻辑会比0.10.2版本稍微复杂有点， 当创建节点时， 发现节点存在, 会先进行判断这个节点的<strong>ephemeralOwnerId</strong>是否与当前sessionId一样， 如果不一样， 就需要重新创建。<br>Zookeeper 的EPHEMERAL节点的ephemeralOwnerId 等于创建他时连接的sessionId，用这个来关联这个zookeeper节点的生命周期， 也就是说， 对应的sesionId的连接过期了， 这个节点就会被自动删除了。</p>
<h4 id="脑裂问题"><a href="#脑裂问题" class="headerlink" title="脑裂问题"></a><strong>脑裂问题</strong></h4><p>我看到有些文章里说， 自从KafkaController有了ControllerEventManager后， 依靠单向队列的方式，可以防止Controller“脑裂事件”发生；</p>
<p>Controller脑裂是指集群中同时存在2个及以上controller；</p>
<p>他们依据是当发生session过期时，<strong>Controller 执行卸任前</strong>，会先将事件队列里的所有事件清空不再执行， 防止与新Controller同时执行发生脑裂。</p>
<p>这个优化确实比老版本好很多， 同时防止了很多脑裂事件，但是在某些情况下，它还是无法防止脑裂问题。</p>
<p>大家先想想，会在什么情况下，它是无法防止脑裂问题的？<br><img src="https://img.alicdn.com/imgextra/i1/O1CN01A7y9th1Z2Kq6aHRab_!!6000000003136-2-tps-1500-678.png" alt=""><br>以下两种情况是会导致脑裂问题的：</p>
<ol>
<li>已经在执行的时间， ControllerEventManager是没法让其停止的；</li>
<li>网络抖动导致的并发问题：我们前面说过ZK上的<strong> /controller节点和/brokers/ids/[101,102,103]</strong>这2个节点都是跟session有关的，一旦<strong>网络抖动导致session过期</strong>， 就有可能触发断开事件。在网络不佳的状态下， 这2个事件触发顺序是不一定的， 如果/brokers/ids/xxx断开的事件先触发， 那么KafkaController会执行<strong>Broker下线的逻辑</strong>（这个逻辑我们后续再讲），如果在<strong>topic分区比较多的情况</strong>，这个下线逻辑是非常耗时的， 比如一个实例他有接近上万个分区， 每次broker下线逻辑要走2分钟之久。 同时Event队列每次只能执行一个事件， 因此在这个Broker下线事件执行完之前， 是无法执行Controller卸任逻辑的。但是别的Broker节点也许网络是正常的， 因此是可以感知/controller节点被删除，就会触发成为Controller，执行Controller相关逻辑， 在这个阶段整个集群就会存在两个Controller。</li>
</ol>
<p>在这个阶段，由于集群同时存在2个Controller，会导致各个节点的metadata信息不一致， 有可能会影响整个集群的isr扩缩容。</p>
<p><strong>那针对这种脑裂问题， Kafka是如何避免的呢？</strong><br>我们先来想下， 为什么会有2个controller，核心就是老的controller不知道已经有新的controller诞生了，因此只需让他知道有新的controller诞生了，自己不要做controller相关的事情就ok了。<br>那老的controller怎么知道有新的controller诞生了呢？这就回到我们前面说过的<strong>/controller_epoch ZK节点</strong>，它表示controller的代数，每次有新的controller诞生， 它就会<strong>递增</strong>。<br><strong>同时ZooKeeper是Kafka持久化状态机的对象， 每次状态机变动前，都会将最新的状态机持久化到Zookeeper上。</strong><br>因此利用Zookeeper事务multiApi，在所有对Zookeeper操作前绑定一个<strong>检测/controller_epoch的zkVersion，如果zkVersion与自己的不一样就会抛出异常，进行卸任Controller。</strong><br>这个问题是在V2.2.0版本修复的： <a href="https://issues.apache.org/jira/browse/KAFKA-7235" target="_blank" rel="noopener">https://issues.apache.org/jira/browse/KAFKA-7235</a>。还是那句老话<strong>还在用0.x 的用户赶紧升级吧</strong>。<br><img src="https://img.alicdn.com/imgextra/i1/O1CN01DlgF4t1tdF4JhPKhM_!!6000000005924-2-tps-1500-384.png" alt=""><br><img src="https://img.alicdn.com/imgextra/i3/O1CN01jZB1yk1Gn4YekSH7G_!!6000000000666-2-tps-1426-634.png" alt=""><br><img src="https://img.alicdn.com/imgextra/i2/O1CN01NUt6ah1K3y0rVOAxI_!!6000000001109-2-tps-1384-508.png" alt=""></p>
<h2 id="2-5-ControllerFailover"><a href="#2-5-ControllerFailover" class="headerlink" title="2.5 ControllerFailover"></a><strong>2.5 ControllerFailover</strong></h2><p>上面详细介绍了KafkaController的竞选和卸任基本流程。现在再来简单讲下节点成为Controller后， 做的<strong>onControllerFailover</strong>操作。</p>
<h3 id="2-5-1-监听Zookeeper状态变化"><a href="#2-5-1-监听Zookeeper状态变化" class="headerlink" title="2.5.1 监听Zookeeper状态变化"></a><strong>2.5.1 监听Zookeeper状态变化</strong></h3><p><img src="https://img.alicdn.com/imgextra/i4/O1CN01Q9VbbD1CBHPcKSCsh_!!6000000000042-2-tps-1500-304.png" alt=""><br>failover第一步操作就是<strong>监听各个zookeeper节点的变化</strong>， 下面我先简单说下他们的作用：</p>
<ul>
<li>子节点变化：</li>
<li>brokerChangeHandler： 当各个broker节点发生上下线时， 会触发调用这个方法； </li>
<li>topicChagneHandler: 当有新建的topic时， 会触发调用这个方法</li>
<li>topicDeletionHandler: 当需要删除某个topic时， 会调用这个这个方法</li>
<li>logDirEventNotificationHandler: 当某块磁盘损耗， 会调用这个方法</li>
<li>isrChangeNotificationHandler: 某个分区的isr发生变化时， 会调用这个方法</li>
<li>数据变化：</li>
<li>preferredReplicaElectionHandler: 当需要优化副本leader时，会调用这个方法</li>
<li>partitionReassignmentHandler: 当需要迁移副本时， 会调用这个方法</li>
</ul>
<p>大家先大概记住这些方法， 我们后续讲状态机的时候， 会再结合这些方法精讲细节逻辑。</p>
<h3 id="2-5-2-初始化上下文"><a href="#2-5-2-初始化上下文" class="headerlink" title="2.5.2 初始化上下文"></a><strong>2.5.2 初始化上下文</strong></h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">def</span> <span class="title">initializeControllerContext</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">  <span class="keyword">val</span> curBrokerAndEpochs = zkClient.getAllBrokerAndEpochsInCluster</span><br><span class="line">  <span class="comment">// 1. 先从zookeeper上获取所有broker节点的接入点信息,  存在controllerContext.liveBrokers对象上， 用来表示所有的broker节点的存活状态</span></span><br><span class="line">  controllerContext.setLiveBrokers(curBrokerAndEpochs)</span><br><span class="line">  <span class="comment">// 2. 再从zookeeper上获取所有topic信息, 存入controllerContext.alltopics对象上，后续可以根据这个信息， 判断topic是新增还是删除；  </span></span><br><span class="line">  controllerContext.setAllTopics(zkClient.getAllTopicsInCluster(<span class="literal">true</span>))</span><br><span class="line">  zkClient.getFullReplicaAssignmentForTopics(controllerContext.allTopics.toSet).foreach &#123;</span><br><span class="line">      <span class="keyword">case</span> (topicPartition, replicaAssignment) =&gt;</span><br><span class="line">      <span class="comment">// 3. 获取所有Topic的分区AR信息，存在controllerContext.partitionAssignments对象上， 也就是说topic每个分区的副本分布情况</span></span><br><span class="line">        controllerContext.updatePartitionFullReplicaAssignment(topicPartition, replicaAssignment)</span><br><span class="line">        <span class="keyword">if</span> (replicaAssignment.isBeingReassigned)</span><br><span class="line">      <span class="comment">// 4. 获取正在迁移副本的分区信息，存入controllerContext.partitionsBeingReassigned上，后续迁移副本都会依据这个对象</span></span><br><span class="line">          controllerContext.partitionsBeingReassigned.add(topicPartition)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 5. 监听这些topic的zookeeper接上的数据变化情况， 主要作用是， 当topic新增分区时，controller能够知道</span></span><br><span class="line">  registerPartitionModificationsHandlers(controllerContext.allTopics.toSeq)</span><br><span class="line">  <span class="comment">// 6. 获取所有topic的当前副本的状态机分配情况，存在controllerContext.partitionLeadershipInfo对象里</span></span><br><span class="line">  updateLeaderAndIsrCache()</span><br><span class="line">  <span class="comment">// 7. 启动channel通信线程， 它的主要作用是KafkaController与其他节点进行通信</span></span><br><span class="line">  controllerChannelManager.startup()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">updateLeaderAndIsrCache</span></span>(partitions: <span class="type">Seq</span>[<span class="type">TopicPartition</span>] = controllerContext.allPartitions.toSeq): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> leaderIsrAndControllerEpochs = zkClient.getTopicPartitionStates(partitions)</span><br><span class="line">    leaderIsrAndControllerEpochs.foreach &#123; <span class="keyword">case</span> (partition, leaderIsrAndControllerEpoch) =&gt;</span><br><span class="line">      controllerContext.partitionLeadershipInfo.put(partition, leaderIsrAndControllerEpoch)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这部操作是<strong>初始化controllerContext</strong>， 看名字就知道这个对象非常重要，你可以理解controller的所有操作结果的上下文都存在这里， 我们后续操作状态机信息， 强依赖这个对象。<br>我将代码精简了一下， 它的主要操作如下：</p>
<ol>
<li>先从zookeeper上获取所有broker节点的接入点信息, 存在<strong>controllerContext.liveBrokers对象上</strong>， 用来表<strong>示所有的broker节点的存活状态；</strong></li>
<li>再从zookeeper<strong>上获取所有topic信息, 存入controllerContext.alltopics对象上</strong>，后续可以根据这个信息， 判断topic是新增还是删除；</li>
<li>获取所有<strong>Topic的分区AR(Assigned Replicas)信息，存在controllerContext.partitionAssignments对象上</strong>， 也就是说topic每个分区的副本分布情况；</li>
<li>获取正在<strong>迁移副本的分区信息</strong>，存到<strong>controllerContext.partitionsBeingReassigned</strong>上，后续迁移副本都会依据这个对象；</li>
<li>监听这些topic的zookeeper节点的数据变化情况， 主要作用是， <strong>当topic新增分区时</strong>，controller能够知道，并做相应处理；</li>
<li>获取所有topic的<strong>当前副本的状态机分配情况，存在controllerContext.partitionLeadershipInfo对象里</strong>；</li>
<li>启动<strong>channel通信线程</strong>， 它的主要作用是<strong>KafkaController与其他节点进行通信</strong>；</li>
</ol>
<p>大家先简单了解一下，不要完全了解细节， 主要是对这几个对象要印象深刻，后续状态机部分会和这些对象息息相关：</p>
<ul>
<li><strong>controllerContext.liveBrokers</strong></li>
<li><strong>controllerContext.alltopics</strong></li>
<li><strong>controllerContext.partitionAssignments</strong></li>
<li><strong>controllerContext.partitionsBeingReassigned</strong></li>
<li><strong>controllerContext.partitionLeadershipInfo</strong><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> (topicsToBeDeleted, topicsIneligibleForDeletion) = fetchTopicDeletionsInProgress()</span><br><span class="line">    topicDeletionManager.init(topicsToBeDeleted, topicsIneligibleForDeletion)</span><br><span class="line"></span><br><span class="line">    info(<span class="string">"Sending update metadata request"</span>)</span><br><span class="line">    sendUpdateMetadataRequest(controllerContext.liveOrShuttingDownBrokerIds.toSeq, <span class="type">Set</span>.empty)</span><br><span class="line"></span><br><span class="line">    replicaStateMachine.startup()</span><br><span class="line">    partitionStateMachine.startup()</span><br><span class="line"></span><br><span class="line">    info(<span class="string">s"Ready to serve as the new controller with epoch <span class="subst">$epoch</span>"</span>)</span><br><span class="line"></span><br><span class="line">    initializePartitionReassignments()</span><br><span class="line">    topicDeletionManager.tryTopicDeletion()</span><br><span class="line">    <span class="keyword">val</span> pendingPreferredReplicaElections = fetchPendingPreferredReplicaElections()</span><br><span class="line">    onReplicaElection(pendingPreferredReplicaElections, <span class="type">ElectionType</span>.<span class="type">PREFERRED</span>, <span class="type">ZkTriggered</span>)</span><br><span class="line">    info(<span class="string">"Starting the controller scheduler"</span>)</span><br><span class="line">    kafkaScheduler.startup()</span><br><span class="line">    <span class="keyword">if</span> (config.autoLeaderRebalanceEnable) &#123;</span><br><span class="line">      scheduleAutoLeaderRebalanceTask(delay = <span class="number">5</span>, unit = <span class="type">TimeUnit</span>.<span class="type">SECONDS</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="2-5-3-剩余流程"><a href="#2-5-3-剩余流程" class="headerlink" title="2.5.3 剩余流程"></a><strong>2.5.3 剩余流程</strong></h3><p><img src="https://img.alicdn.com/imgextra/i3/O1CN01gYkGcN1cFZ7x2GD6i_!!6000000003571-2-tps-1494-980.png" alt=""><br>剩余的流程， 主要都是初始化各个管理器：</p>
<ol>
<li><strong>初始化删除topic管理器</strong>， 后续的topic流程， 都由它管控；</li>
<li>启动<strong>副本状态机管理器</strong>，这个对象非常重要， 所有副本的状态都由它来控制；</li>
<li>启动<strong>分区状态机管理器</strong>，这个对象非常重要， 所有副本的leader都由它控制；</li>
<li>初始副本迁移流程， 之前没有迁移完毕的流程， 从这恢复开始；</li>
<li>重新触发未删除的topic的流程，<strong>因此我们经常删除topic失败， 重选controller就能删除成功</strong>， 其实关键步骤就在这里， 这里会重新开始删除；</li>
<li>根据分区的AR分配情况， <strong>优化各节点leader分配情况</strong>， 这个后面再讲；</li>
<li>启动调度器， 后续KafkaController的调度任务都由它来完成；</li>
<li>定时调度优化各节点的leader分区情况；</li>
</ol>
<p>上面这些对象都是非常重要的对象， 后面状态机部分，我们再细讲他们的功能， 先有个印象吧。</p>
<h2 id="2-6-ControllerResignation"><a href="#2-6-ControllerResignation" class="headerlink" title="2.6 ControllerResignation"></a><strong>2.6 ControllerResignation</strong></h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">onControllerResignation</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    debug(<span class="string">"Resigning"</span>)</span><br><span class="line">    <span class="comment">// de-register listeners</span></span><br><span class="line">    zkClient.unregisterZNodeChildChangeHandler(isrChangeNotificationHandler.path)</span><br><span class="line">    zkClient.unregisterZNodeChangeHandler(partitionReassignmentHandler.path)</span><br><span class="line">    zkClient.unregisterZNodeChangeHandler(preferredReplicaElectionHandler.path)</span><br><span class="line">    zkClient.unregisterZNodeChildChangeHandler(logDirEventNotificationHandler.path)</span><br><span class="line">    unregisterBrokerModificationsHandler(brokerModificationsHandlers.keySet)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// shutdown leader rebalance scheduler</span></span><br><span class="line">    kafkaScheduler.shutdown()</span><br><span class="line">    offlinePartitionCount = <span class="number">0</span></span><br><span class="line">    preferredReplicaImbalanceCount = <span class="number">0</span></span><br><span class="line">    globalTopicCount = <span class="number">0</span></span><br><span class="line">    globalPartitionCount = <span class="number">0</span></span><br><span class="line">    topicsToDeleteCount = <span class="number">0</span></span><br><span class="line">    replicasToDeleteCount = <span class="number">0</span></span><br><span class="line">    ineligibleTopicsToDeleteCount = <span class="number">0</span></span><br><span class="line">    ineligibleReplicasToDeleteCount = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// stop token expiry check scheduler</span></span><br><span class="line">    <span class="keyword">if</span> (tokenCleanScheduler.isStarted)</span><br><span class="line">      tokenCleanScheduler.shutdown()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// de-register partition ISR listener for on-going partition reassignment task</span></span><br><span class="line">    unregisterPartitionReassignmentIsrChangeHandlers()</span><br><span class="line">    <span class="comment">// shutdown partition state machine</span></span><br><span class="line">    partitionStateMachine.shutdown()</span><br><span class="line">    zkClient.unregisterZNodeChildChangeHandler(topicChangeHandler.path)</span><br><span class="line">    unregisterPartitionModificationsHandlers(partitionModificationsHandlers.keys.toSeq)</span><br><span class="line">    zkClient.unregisterZNodeChildChangeHandler(topicDeletionHandler.path)</span><br><span class="line">    <span class="comment">// shutdown replica state machine</span></span><br><span class="line">    replicaStateMachine.shutdown()</span><br><span class="line">    zkClient.unregisterZNodeChildChangeHandler(brokerChangeHandler.path)</span><br><span class="line"></span><br><span class="line">    controllerChannelManager.shutdown()</span><br><span class="line">    controllerContext.resetContext()</span><br><span class="line"></span><br><span class="line">    info(<span class="string">"Resigned"</span>)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><strong>卸任Controller</strong>具体逻辑我就不细讲了， 其实看代码就知道， 它和<strong>ControllerFailover</strong>是对应的， 就是将之前初始的内容摘除，防止与新Controller之间存在<strong>“脑裂情况”和内存泄露</strong>等。</p>
<h1 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h1><p>上面主要细讲了Controller的竞选和卸任的逻辑， failover和resignation只是稍微提了一下， 主要是让大家对一些对象混个眼熟， 具体细节我们在状态机部分细讲， 这样大家理论起来更加方便。</p>
<p>大家可以看下下面的时序图和流程图， 来回顾一下上面讲得内容。</p>
<h2 id="3-1-时序图"><a href="#3-1-时序图" class="headerlink" title="3.1 时序图"></a>3.1 时序图</h2><p><img src="https://img.alicdn.com/imgextra/i1/O1CN016rnPKj1go9UrZwksi_!!6000000004188-2-tps-1782-611.png" alt=""></p>
<h2 id="3-2-流程图"><a href="#3-2-流程图" class="headerlink" title="3.2 流程图"></a>3.2 流程图</h2><p><img src="https://img.alicdn.com/imgextra/i3/O1CN01bkl04P1OzSBu38lvO_!!6000000001776-2-tps-1500-959.png" alt="image.png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.hellolc.com/2022/02/20/KafkaController的生命周期/" data-id="cl7e5jfgb001pdo5wr4ze6c1i" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/kafka/">kafka</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2021/10/20/FastJSON Key Hash冲突问题/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">FastJSON Key Hash冲突问题</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Core-HTML5-Canvas/">Core HTML5 Canvas</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JAVA/">JAVA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript-Web-Applications/">JavaScript Web Applications</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript设计模式与开发实践/">JavaScript设计模式与开发实践</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Jquery/">Jquery</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Pro-Git/">Pro Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ReactNative/">ReactNative</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vim实用技巧/">Vim实用技巧</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/You-Don-t-Know-JS/">You Don't Know JS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css/">css</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/html5/">html5</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javaScript高级程序设计笔记/">javaScript高级程序设计笔记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kafka/">kafka</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux系统编程/">linux系统编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tools/">tools</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构与算法/">数据结构与算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/深入React技术栈/">深入React技术栈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/深入浅出Node-js/">深入浅出Node.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/深入理解计算机系统/">深入理解计算机系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Core-HTML5-Canvas/" style="font-size: 12px;">Core HTML5 Canvas</a> <a href="/tags/JAVA/" style="font-size: 10px;">JAVA</a> <a href="/tags/JavaScript/" style="font-size: 18px;">JavaScript</a> <a href="/tags/JavaScript-Web-Applications/" style="font-size: 12px;">JavaScript Web Applications</a> <a href="/tags/JavaScript设计模式与开发实践/" style="font-size: 10px;">JavaScript设计模式与开发实践</a> <a href="/tags/Jquery/" style="font-size: 10px;">Jquery</a> <a href="/tags/Pro-Git/" style="font-size: 10px;">Pro Git</a> <a href="/tags/ReactNative/" style="font-size: 12px;">ReactNative</a> <a href="/tags/Vim实用技巧/" style="font-size: 10px;">Vim实用技巧</a> <a href="/tags/You-Don-t-Know-JS/" style="font-size: 16px;">You Don't Know JS</a> <a href="/tags/css/" style="font-size: 12px;">css</a> <a href="/tags/html5/" style="font-size: 10px;">html5</a> <a href="/tags/javaScript高级程序设计笔记/" style="font-size: 20px;">javaScript高级程序设计笔记</a> <a href="/tags/kafka/" style="font-size: 10px;">kafka</a> <a href="/tags/linux系统编程/" style="font-size: 10px;">linux系统编程</a> <a href="/tags/tools/" style="font-size: 10px;">tools</a> <a href="/tags/数据结构与算法/" style="font-size: 10px;">数据结构与算法</a> <a href="/tags/深入React技术栈/" style="font-size: 14px;">深入React技术栈</a> <a href="/tags/深入浅出Node-js/" style="font-size: 10px;">深入浅出Node.js</a> <a href="/tags/深入理解计算机系统/" style="font-size: 10px;">深入理解计算机系统</a> <a href="/tags/算法/" style="font-size: 12px;">算法</a> <a href="/tags/设计模式/" style="font-size: 10px;">设计模式</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">October 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">August 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">February 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">December 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/02/20/KafkaController的生命周期/">KafkaController的生命周期</a>
          </li>
        
          <li>
            <a href="/2021/10/20/FastJSON Key Hash冲突问题/">FastJSON Key Hash冲突问题</a>
          </li>
        
          <li>
            <a href="/2018/05/18/设计模式/">设计模式</a>
          </li>
        
          <li>
            <a href="/2018/05/09/数据结构/">数据结构与算法</a>
          </li>
        
          <li>
            <a href="/2018/05/06/Drawing/">Drawing</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2022 lichen<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>