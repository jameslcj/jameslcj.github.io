{"tags":[{"name":"JavaScript","permalink":"http://blog.hellolc.com/tags/JavaScript/","url":"/async/tags/JavaScript.json","count":6}],"categories":[],"url":"/async/posts/2017/01/18/JavaScript原型和原型链.json","date":1484741682000,"path":{"year":2017,"month":1,"day":18,"name":"JavaScript原型和原型链"},"title":"JavaScript原型和原型链","permalink":"http://blog.hellolc.com/2017/01/18/JavaScript原型和原型链/","content":"<h3 id=\"原型继承方法\"><a href=\"#原型继承方法\" class=\"headerlink\" title=\"原型继承方法\"></a>原型继承方法</h3><ul>\n<li><p>原型继承有如下2种方式:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">var BaseCalculator = function() &#123;</div><div class=\"line\">    this.decimalDigits = 2;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">BaseCalculator.prototype = &#123;</div><div class=\"line\">    add: function(x, y) &#123;</div><div class=\"line\">        return x + y;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    subtract: function(x, y) &#123;</div><div class=\"line\">        return x - y;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">var Calculator = function () &#123;</div><div class=\"line\">    //为每个实例都声明一个税收数字</div><div class=\"line\">    this.tax = 5;</div><div class=\"line\">&#125;;</div><div class=\"line\">// 原型继承有如下2种方式:</div><div class=\"line\">Calculator.prototype = new BaseCalculator();</div><div class=\"line\">Calculator.prototype = BaseCalculator.prototype;</div><div class=\"line\"></div><div class=\"line\">var calc =newCalculator();</div><div class=\"line\">alert(calc.add(1, 1));</div><div class=\"line\">alert(calc.decimalDigits);</div></pre></td></tr></table></figure>\n</li>\n<li><p>2种继承方式的区别: </p>\n<ul>\n<li>第一种继承要是能够访问到calc.decimalDigits的值 </li>\n<li>而第二种无法访问到calc.decimalDigits; </li>\n<li>因为第一种是将 BaseCalculator的实例赋值给Calculator.prototype, 所以能够访问到其对应的属性, 并且所有Calculator都公用一个BaseCalculator实例, 而第二种没有实例, 所以无法访问</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"如何判断对象是否有对应的属性比较安全\"><a href=\"#如何判断对象是否有对应的属性比较安全\" class=\"headerlink\" title=\"如何判断对象是否有对应的属性比较安全\"></a>如何判断对象是否有对应的属性比较安全</h3><ul>\n<li>对象的hasOwnProperty方法, 可以用来判别是否是自己上的属性或方法, </li>\n<li>但是对象的hasOwnProperty很容易被修改, 所以我们应该使用<br>{}.hasOwnProperty.call(foo, ‘bar’);来判断 更加可靠安全</li>\n</ul>\n<h3 id=\"proto属性\"><a href=\"#proto属性\" class=\"headerlink\" title=\"proto属性\"></a><strong>proto</strong>属性</h3><ul>\n<li>每个对象都有一个<code>__proto__</code>隐式属性, 他指向该对象的原型, 既<code>prototype</code></li>\n<li>可以直接用<code>__proto__</code>属性改变实例对象的原型链</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">var a = &#123;</div><div class=\"line\">  x: 10,</div><div class=\"line\">  calculate: function (z) &#123;</div><div class=\"line\">    return this.x + this.y + z</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"> </div><div class=\"line\">var b = &#123;</div><div class=\"line\">  y: 20,</div><div class=\"line\">  __proto__: a</div><div class=\"line\">&#125;;</div><div class=\"line\">var c = &#123;</div><div class=\"line\">  y: 30,</div><div class=\"line\">  __proto__: a</div><div class=\"line\">&#125;;</div><div class=\"line\"> </div><div class=\"line\">// 调用继承过来的方法</div><div class=\"line\">b.calculate(30); // 60</div><div class=\"line\">c.calculate(40); // 80</div><div class=\"line\"></div><div class=\"line\">var d = &#123;</div><div class=\"line\">    x: 20,</div><div class=\"line\">    calculate: function (z) &#123;</div><div class=\"line\">        return this.x + this.y + z</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">c.__proto__ = d;</div><div class=\"line\">c.calculate(40); //90</div></pre></td></tr></table></figure>\n<h3 id=\"with会改变作用域\"><a href=\"#with会改变作用域\" class=\"headerlink\" title=\"with会改变作用域\"></a>with会改变作用域</h3><ul>\n<li>with会把原型链<code>__proto__</code>改变到<code>Object.prototype</code>上</li>\n<li>每个上下文执行环境都有变量对象(variable object)，this指针(this value)，作用域链(scope chain) 这3个属性</li>\n<li>在代码执行过程中，如果使用with或者catch语句就会改变作用域链。而这些对象都是一些简单对象，他们也会有原型链。这样的话，作用域链会从两个维度来搜寻。<ul>\n<li>首先在原本的作用域链</li>\n<li>每一个链接点的作用域的链（如果这个链接点是有prototype的话）</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\">Object.prototype.x = 10;</div><div class=\"line\"> </div><div class=\"line\">var w = 20;</div><div class=\"line\">var y = 30;</div><div class=\"line\"> </div><div class=\"line\">// 在SpiderMonkey全局对象里</div><div class=\"line\">// 例如，全局上下文的变量对象是从&quot;Object.prototype&quot;继承到的</div><div class=\"line\">// 所以我们可以得到“没有声明的全局变量”</div><div class=\"line\">// 因为可以从原型链中获取</div><div class=\"line\"> </div><div class=\"line\">console.log(x); // 10</div><div class=\"line\"> </div><div class=\"line\">(function foo() &#123;</div><div class=\"line\"> </div><div class=\"line\">  // &quot;foo&quot; 是局部变量</div><div class=\"line\">  var w = 40;</div><div class=\"line\">  var x = 100;</div><div class=\"line\"> </div><div class=\"line\">  // &quot;x&quot; 可以从&quot;Object.prototype&quot;得到，注意值是10哦</div><div class=\"line\">  // 因为&#123;z: 50&#125;是从它那里继承的</div><div class=\"line\"> </div><div class=\"line\">  with (&#123;z: 50&#125;) &#123;</div><div class=\"line\">    console.log(w, x, y , z); // 40, 10, 30, 50</div><div class=\"line\">  &#125;</div><div class=\"line\"> </div><div class=\"line\">  // 在&quot;with&quot;对象从作用域链删除之后</div><div class=\"line\">  // x又可以从foo的上下文中得到了，注意这次值又回到了100哦</div><div class=\"line\">  // &quot;w&quot; 也是局部变量</div><div class=\"line\">  console.log(x, w); // 100, 40</div><div class=\"line\"> </div><div class=\"line\">  // 在浏览器里</div><div class=\"line\">  // 我们可以通过如下语句来得到全局的w值</div><div class=\"line\">  console.log(window.w); // 20</div><div class=\"line\"> </div><div class=\"line\">&#125;)();</div></pre></td></tr></table></figure>\n<h3 id=\"AO变量对象\"><a href=\"#AO变量对象\" class=\"headerlink\" title=\"AO变量对象\"></a>AO变量对象</h3><ul>\n<li>当进入执行上下文(代码执行之前)时，VO里已经包含了下列属性<ul>\n<li>函数的所有形参(如果我们是在函数执行上下文中)</li>\n<li>由名称和对应值组成的一个变量对象的属性被创建；没有传递对应参数的话，那么由名称和undefined值组成的一种变量对象的属性也将被创建。</li>\n<li>所有函数声明(FunctionDeclaration, FD)—由名称和对应值（函数对象(function-object)）组成一个变量对象的属性被创建；如果变量对象已经存在相同名称的属性，则完全替换这个属性。</li>\n<li>所有变量声明(var, VariableDeclaration)—由名称和对应值（undefined）组成一个变量对象的属性被创建；如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性。</li>\n<li>函数表达式是不在AO对象里生成变量, 但是把函数表达式赋值给一个声明的变量, 那边这个变量会以undefined的方式存放在AO对象里</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"全局变量和var变量的区别\"><a href=\"#全局变量和var变量的区别\" class=\"headerlink\" title=\"全局变量和var变量的区别\"></a>全局变量和var变量的区别</h3><ul>\n<li>关于变量，还有一个重要的知识点。变量相对于简单属性来说，变量有一个特性(attribute)：{DontDelete},这个特性的含义就是不能用delete操作符直接删除变量属性。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">a = 10;</div><div class=\"line\">alert(window.a); // 10</div><div class=\"line\"> </div><div class=\"line\">alert(delete a); // true</div><div class=\"line\"> </div><div class=\"line\">alert(window.a); // undefined</div><div class=\"line\"> </div><div class=\"line\">var b = 20;</div><div class=\"line\">alert(window.b); // 20</div><div class=\"line\"> </div><div class=\"line\">alert(delete b); // false</div><div class=\"line\"> </div><div class=\"line\">alert(window.b); // still 20</div><div class=\"line\"></div><div class=\"line\">但是这个规则在有个上下文里不起走样，那就是eval上下文，变量没有&#123;DontDelete&#125;特性。</div><div class=\"line\">eval(&apos;var a = 10;&apos;);</div><div class=\"line\">alert(window.a); // 10</div><div class=\"line\"> </div><div class=\"line\">alert(delete a); // true</div><div class=\"line\"> </div><div class=\"line\">alert(window.a); // undefined</div></pre></td></tr></table></figure>\n</li>\n</ul>\n"}