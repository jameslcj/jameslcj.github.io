{"tags":[{"name":"javaScript高级程序设计笔记","permalink":"http://blog.hellolc.com/tags/javaScript高级程序设计笔记/","url":"/async/tags/javaScript高级程序设计笔记.json","count":4}],"categories":[],"url":"/async/posts/2017/06/29/面向对象的程序设计.json","date":1498703108000,"path":{"year":2017,"month":6,"day":29,"name":"面向对象的程序设计"},"title":"面向对象的程序设计","permalink":"http://blog.hellolc.com/2017/06/29/面向对象的程序设计/","content":"<h2 id=\"理解对象\"><a href=\"#理解对象\" class=\"headerlink\" title=\"理解对象\"></a>理解对象</h2><blockquote>\n<p>Object.defineProperty(操作对象, 操作属性, 属性类型) IE8及以下不要使用<br>Object.defineProperties(操作对象, {}) 同事可以定义多个属性  支持IE9+<br>Object.getOwnPropertyDescriptor(操作对象, 属性)</p>\n</blockquote>\n<h3 id=\"属性类型\"><a href=\"#属性类型\" class=\"headerlink\" title=\"属性类型\"></a>属性类型</h3><ul>\n<li>[[configurable]]: 是否可以配置, 能够通过delete删除属性, 修改其属性特性(可以理解为修改属性名), 默认true</li>\n<li>[[enumerable]]: 表示能否通过for-in遍历, 默认true</li>\n<li>[[writable]]: 表示能否修改属性的值</li>\n<li>[[value]]: 属性的数据值, 默认undefined</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">var obj = &#123;&#125;</div><div class=\"line\">Object.defineProperty(obj, &quot;name&quot;, &#123;</div><div class=\"line\">  writable: false,</div><div class=\"line\">  value: &quot;hello&quot;</div><div class=\"line\">&#125;);</div><div class=\"line\">console.log(obj)//Object &#123;name: &quot;hello&quot;&#125;</div><div class=\"line\">obj.name = &apos;world&apos;</div><div class=\"line\">console.log(obj)//Object &#123;name: &quot;hello&quot;&#125;</div><div class=\"line\">// 一下就配置了writable和value, 没有配置configurable和enumerable 那么这两个值默认为false了</div><div class=\"line\">delete obj.name //false</div></pre></td></tr></table></figure>\n<h3 id=\"访问器属性\"><a href=\"#访问器属性\" class=\"headerlink\" title=\"访问器属性\"></a>访问器属性</h3><h4 id=\"getter-setter\"><a href=\"#getter-setter\" class=\"headerlink\" title=\"getter setter\"></a>getter setter</h4><ul>\n<li>[[configurable]]: 是否可以配置, 能够通过delete删除属性, 修改其属性特性(可以理解为修改属性名), 默认true</li>\n<li>[[enumerable]]: 表示能否通过for-in遍历, 默认true</li>\n<li>[[get]]: 在读取属性时调用的函数, 默认undefined</li>\n<li>[[set]]: 在写入属性时调用的函数, 默认undefined</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">var obj = &#123;_age: 20&#125;</div><div class=\"line\">//get和set方法 忽略其中一个方法, 说明那方法设置为false</div><div class=\"line\">Object.defineProperty(obj, &quot;age&quot;, &#123;</div><div class=\"line\">    get: function() &#123;</div><div class=\"line\">        return this._age;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    set: function(newVal) &#123;</div><div class=\"line\">        if (newVal &gt; 18) &#123;</div><div class=\"line\">            this._age = 18;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            this._age = newVal;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div><div class=\"line\">obj.age = 55 //18</div><div class=\"line\">obj.age = 16 //16</div></pre></td></tr></table></figure>\n<h2 id=\"创建对象\"><a href=\"#创建对象\" class=\"headerlink\" title=\"创建对象\"></a>创建对象</h2><h3 id=\"创建对象的几种方式\"><a href=\"#创建对象的几种方式\" class=\"headerlink\" title=\"创建对象的几种方式\"></a>创建对象的几种方式</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">function Person(name, age) &#123;</div><div class=\"line\">  this.name = name;</div><div class=\"line\">  this.age = age;</div><div class=\"line\">  this.getName = function() &#123;</div><div class=\"line\">    return this.name;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">var p1 = new Person(&apos;p1&apos;, 18);</div><div class=\"line\">//--</div><div class=\"line\">var obj = new Object();</div><div class=\"line\">Person.call(obj, &apos;p2&apos;, 18);</div><div class=\"line\">obj.getName() //&apos;p2&apos;</div></pre></td></tr></table></figure>\n<h3 id=\"为什么要用原型的方式实例化\"><a href=\"#为什么要用原型的方式实例化\" class=\"headerlink\" title=\"为什么要用原型的方式实例化\"></a>为什么要用原型的方式实例化</h3><blockquote>\n<p>原型继承可以共享属性和方法</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">//普通的</div><div class=\"line\">function Person(name, age) &#123;</div><div class=\"line\">  this.name = name;</div><div class=\"line\">  this.age = age;</div><div class=\"line\">  //这种方式等价于 new Function(&quot;return this.name;&quot;); 当实例多个对象时, 此方法也被实例了多次, 不公用一个方法</div><div class=\"line\">  this.getName = function() &#123;</div><div class=\"line\">    return this.name;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//原型链的</div><div class=\"line\">function Person(name, age) &#123;</div><div class=\"line\">  this.name = name;</div><div class=\"line\">  this.age = age;</div><div class=\"line\">&#125;</div><div class=\"line\">//如果使用原型链继承的方式, 就可以共用同一个方法</div><div class=\"line\">Person.prototype.getName = function() &#123;</div><div class=\"line\">  return this.name;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"获取原型的方法\"><a href=\"#获取原型的方法\" class=\"headerlink\" title=\"获取原型的方法\"></a>获取原型的方法</h3><blockquote>\n<p>构造方法.prototype === Object.getPrototypeOf(实例对象)</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">function Person() &#123;</div><div class=\"line\">&#125;</div><div class=\"line\">Person.prototype.getName = function() &#123;</div><div class=\"line\">  return this.name;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">ver person = new Person;</div><div class=\"line\"></div><div class=\"line\">Object.getPrototypeOf(person) === Person.prototype //true</div><div class=\"line\">//判断是否是某一对象的原型</div><div class=\"line\">Person.prototype.isPrototypeOf(person) //true</div></pre></td></tr></table></figure>\n<h3 id=\"修改原型上的属性值\"><a href=\"#修改原型上的属性值\" class=\"headerlink\" title=\"修改原型上的属性值\"></a>修改原型上的属性值</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">function Person() &#123;</div><div class=\"line\">&#125;</div><div class=\"line\">Person.prototype.name = &apos;hello&apos;</div><div class=\"line\">var person = new Person();</div><div class=\"line\"></div><div class=\"line\">//默认使用原型上的值</div><div class=\"line\">person.name; //hello</div><div class=\"line\">person.hasOwnProperty(&apos;name&apos;);//false</div><div class=\"line\">//覆盖原型上的值</div><div class=\"line\">person.name = &apos;world&apos;;</div><div class=\"line\">person.name;// world</div><div class=\"line\">person.hasOwnProperty(&apos;name&apos;);//true</div><div class=\"line\">//删除自定义的值</div><div class=\"line\">delete person.name; //true</div><div class=\"line\">//重新指向原型上的值</div><div class=\"line\">person.name; //hello</div><div class=\"line\">person.hasOwnProperty(&apos;name&apos;);//false</div></pre></td></tr></table></figure>\n<h3 id=\"Object-getOwnPropertyNames-与-Object-keys-的区别\"><a href=\"#Object-getOwnPropertyNames-与-Object-keys-的区别\" class=\"headerlink\" title=\"Object.getOwnPropertyNames() 与 Object.keys()的区别\"></a>Object.getOwnPropertyNames() 与 Object.keys()的区别</h3><blockquote>\n<p>Object.keys()只能获取可以枚举的key<br>Object.getOwnPropertyNames() 可以获取所有key(不包括原型链上的key)</p>\n</blockquote>\n<h3 id=\"使用对象字面量原型继承\"><a href=\"#使用对象字面量原型继承\" class=\"headerlink\" title=\"使用对象字面量原型继承\"></a>使用对象字面量原型继承</h3><blockquote>\n<p>使用这种方式会将constructor的指向改变为Object, 因为原型直接被一个对象覆盖</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">Test.prototype = &#123;</div><div class=\"line\">    name: &apos;zhichen&apos;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">test.constructor == Test //false</div><div class=\"line\">test.constructor == Object//true</div><div class=\"line\"></div><div class=\"line\">test instanceof Test //true</div><div class=\"line\">test instanceof Object //true</div></pre></td></tr></table></figure>\n<blockquote>\n<p>为了避免这种问题, 我们需要手动改变constructor指向, 但是这样会使这个key的枚举性变为true(默认是false)</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">Test.prototype = &#123;</div><div class=\"line\">    constructor: Test,</div><div class=\"line\">    name: &apos;zhichen&apos;</div><div class=\"line\">&#125;</div><div class=\"line\">test.constructor == Test //true</div><div class=\"line\">test.constructor == Object//false</div><div class=\"line\"></div><div class=\"line\">test instanceof Test //true</div><div class=\"line\">test instanceof Object //true</div><div class=\"line\"></div><div class=\"line\">Object.keys(Test.prototype)// [&quot;constructor&quot;, &quot;name&quot;]</div></pre></td></tr></table></figure>\n<blockquote>\n<p>所以正确的姿势如下</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">Test.prototype = &#123;</div><div class=\"line\">    name: &apos;zhichen&apos;</div><div class=\"line\">&#125;</div><div class=\"line\">Object.defineProperty(Test.prototype, &quot;constructor&quot;, &#123;</div><div class=\"line\">    enumerable: false,</div><div class=\"line\">    value: Test</div><div class=\"line\">&#125;);</div><div class=\"line\">Object.keys(Test.prototype)//[&quot;name&quot;]</div></pre></td></tr></table></figure>\n<h3 id=\"原型的动态\"><a href=\"#原型的动态\" class=\"headerlink\" title=\"原型的动态\"></a>原型的动态</h3><blockquote>\n<p>由于每个对象当没有找对对应的key时都会去原型链上查找, 所以当我们动态改变原型上的属性, 会有可能直接影响到对象, 即使先实例对象<br>对象和原型之间的关系, 是用指针链接的, 而不是副本形式</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">Test.prototype = &#123;</div><div class=\"line\">    constructor: Test,</div><div class=\"line\">    name: &apos;zhichen&apos;</div><div class=\"line\">&#125;</div><div class=\"line\">var test = new Test()</div><div class=\"line\">test.sayHi(); //ERROR</div><div class=\"line\">Test.prototype.sayHi = function()&#123;</div><div class=\"line\">    console.log(&quot;hello wolrd&quot;);</div><div class=\"line\">&#125;</div><div class=\"line\">test.sayHi()//hello world</div></pre></td></tr></table></figure>\n<blockquote>\n<p>使用字面量对象赋值, 会改变构造函数原型指针指向, 重新指向新原型对象, 但是之前实例化的对象还是指向原来的原型对象, 所以无法获取新原型对象的属性</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">function Test()&#123;&#125;</div><div class=\"line\">var test = new Test()</div><div class=\"line\">Test.prototype = &#123;</div><div class=\"line\">    constructor: Test,</div><div class=\"line\">    name: &apos;zhichen&apos;,</div><div class=\"line\">\t  sayHi: function() &#123;</div><div class=\"line\">\t\t    console.log(&quot;hello world&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">test.sayHi()//ERROR</div></pre></td></tr></table></figure>\n<h3 id=\"原型对象的问题\"><a href=\"#原型对象的问题\" class=\"headerlink\" title=\"原型对象的问题\"></a>原型对象的问题</h3><blockquote>\n<p>因为原型对象是公用同一个对象, 所以当对对象进行操作时, 会影响到其他对象的结果</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">function Test()&#123;&#125;</div><div class=\"line\">Test.prototype.hobby = [];</div><div class=\"line\">var t1 = new Test()</div><div class=\"line\">var t2 = new Test()</div><div class=\"line\">console.log(t1.hobby)//[]</div><div class=\"line\">console.log(t2.hobby)//[]</div><div class=\"line\">t1.hobby.push(&apos;coding&apos;);</div><div class=\"line\">console.log(t1.hobby)//[&quot;coding&quot;]</div><div class=\"line\">console.log(t2.hobby)//[&quot;coding&quot;]</div></pre></td></tr></table></figure>\n<h3 id=\"组合使用构造函数模式和原型模式\"><a href=\"#组合使用构造函数模式和原型模式\" class=\"headerlink\" title=\"组合使用构造函数模式和原型模式\"></a>组合使用构造函数模式和原型模式</h3><blockquote>\n<p>这种模式, 每个实例都有自己的一份实例属性的副本, 但同时共享着对方法的引用, 这样最大限度的节约了内存, 同时构造方法可以接受传参实例化, 也避免了引用类型属性改变引发污染其他对象属性</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">function Test(name, age) &#123;</div><div class=\"line\">  this.name = name;</div><div class=\"line\">  this.age = age;</div><div class=\"line\">  this.hobby = [];</div><div class=\"line\">&#125;</div><div class=\"line\">Test.prototype.sayName = function() &#123;</div><div class=\"line\">  console.log(&apos;my name is &apos; + this.name)</div><div class=\"line\">&#125;</div><div class=\"line\">var t1 = new Test(&apos;a&apos;, 1)</div><div class=\"line\">var t2 = new Test(&apos;b&apos;, 2)</div><div class=\"line\">console.log(t1.hobby)//[]</div><div class=\"line\">console.log(t2.hobby)//[]</div><div class=\"line\">t1.hobby.push(&apos;coding&apos;);</div><div class=\"line\">console.log(t1.hobby)//[&quot;coding&quot;]</div><div class=\"line\">console.log(t2.hobby)//[]</div><div class=\"line\">t1.sayName()//&quot;a&quot;</div><div class=\"line\">t2.sayName()//&quot;b&quot;</div><div class=\"line\">console.log(t1.sayName === t2.sayName)//true</div><div class=\"line\">console.log(t1.hobby === t2.hobby)//false</div></pre></td></tr></table></figure>\n<h3 id=\"寄生构造函数模式\"><a href=\"#寄生构造函数模式\" class=\"headerlink\" title=\"寄生构造函数模式\"></a>寄生构造函数模式</h3><blockquote>\n<p>与工厂模式类似</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">function Test(name, age) &#123;</div><div class=\"line\">  var o = new Object();</div><div class=\"line\">  o.name = name;</div><div class=\"line\">  o.age = age;</div><div class=\"line\">  o.sayName = function() &#123;</div><div class=\"line\">    console.log(this.name)</div><div class=\"line\">  &#125;</div><div class=\"line\">  return o;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var test = new Test(&apos;test&apos;, 1);</div><div class=\"line\">test.sayName();//&quot;test&quot;</div></pre></td></tr></table></figure>\n<h2 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h2><h3 id=\"原型链\"><a href=\"#原型链\" class=\"headerlink\" title=\"原型链\"></a>原型链</h3><blockquote>\n<p>需要注意的一点是: property其实是SubType.prototype上的属性, 因为SuperType的实例复制给了SubType.prototype, 而getSuperValue还是在SuperType.prototype上; 因此这样会导致引用类型的值会被共享; 而且无法区分他们是父类还是子类的实例</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">function SuperType() &#123;</div><div class=\"line\">  this.property = true;</div><div class=\"line\">  this.hobby = [];</div><div class=\"line\">&#125;</div><div class=\"line\">SuperType.prototype.getSuperValue = function() &#123;</div><div class=\"line\">  return this.property;</div><div class=\"line\">&#125;</div><div class=\"line\">function SubType() &#123;</div><div class=\"line\">  this.subProperty = false;</div><div class=\"line\">&#125;</div><div class=\"line\">SubType.prototype = new SuperType();</div><div class=\"line\">SubType.prototype.getSubValue = function() &#123;</div><div class=\"line\">  return this.subProperty;</div><div class=\"line\">&#125;</div><div class=\"line\">var instance = new SubType();</div><div class=\"line\">console.log(instance.getSuperValue())//true</div><div class=\"line\">var instance2 = new SubType();</div><div class=\"line\">instance2.hobby.push(&apos;coding&apos;);</div><div class=\"line\">console.log(instance.hobby)//[&quot;coding&quot;]</div><div class=\"line\">console.log(instance2.hobby)//[&quot;coding&quot;]</div><div class=\"line\">instance instanceof SuperType//true</div><div class=\"line\">instance instanceof SubType//true</div></pre></td></tr></table></figure>\n<h3 id=\"借用构造函数\"><a href=\"#借用构造函数\" class=\"headerlink\" title=\"借用构造函数\"></a>借用构造函数</h3><blockquote>\n<p>解决父类引用类型在继承时共享<br>在子类中call父类, 这样子类的每个实例都会有父类的属性副本;<br>还有一个好处就是: 给父类构造函数传参的值可以根据不同的子类实例对象不同而改变;<br>也能够区别是父类还是子类的实例</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">function SuperType(name) &#123;</div><div class=\"line\">  this.name = name;</div><div class=\"line\">  this.hobby = [];</div><div class=\"line\">&#125;</div><div class=\"line\">function SubType(name) &#123;</div><div class=\"line\">  //继承了SuperType</div><div class=\"line\">  SuperType.call(this, name);</div><div class=\"line\">&#125;</div><div class=\"line\">var instance1 = new SubType(&apos;hello&apos;);</div><div class=\"line\">var instance2= new SubType(&apos;world&apos;);</div><div class=\"line\">instance1.hobby.push(&apos;coding&apos;);</div><div class=\"line\">console.log(instance1.hobby)//[&quot;coding&quot;]</div><div class=\"line\">console.log(instance2.hobby)//[]</div><div class=\"line\">console.log(instance1.name)//&quot;hello&quot;</div><div class=\"line\">console.log(instance2.name)//&quot;world&quot;</div><div class=\"line\">instance1 instanceof SuperType//false</div><div class=\"line\">instance1 instanceof SubType//true</div></pre></td></tr></table></figure>\n<h3 id=\"原型式继承\"><a href=\"#原型式继承\" class=\"headerlink\" title=\"原型式继承\"></a>原型式继承</h3><blockquote>\n<p>它对传入的对象是潜复制, 因此会导致引用属性对象会被共享;<br>它的功能和<code>Obejct.create()</code>行为相同</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">function object(o) &#123;</div><div class=\"line\">  function F() &#123;&#125;</div><div class=\"line\">  F.prototype = o;</div><div class=\"line\">  return new F();</div><div class=\"line\">&#125;</div><div class=\"line\">var obj = &#123;</div><div class=\"line\">  name: &apos;hello&apos;,</div><div class=\"line\">  hobby: []</div><div class=\"line\">&#125;</div><div class=\"line\">var instance1 = object(obj);</div><div class=\"line\">var instance2 = object(obj);</div><div class=\"line\">instance1.hobby.push(&apos;coding&apos;);</div><div class=\"line\">console.log(instance1.hobby)//[&quot;coding&quot;]</div><div class=\"line\">console.log(instance2.hobby)//[&quot;coding&quot;]</div><div class=\"line\">var instance3 = Object.create(obj)</div><div class=\"line\">var instance4 = Object.create(obj)</div><div class=\"line\">instance3.hobby.push(&apos;running&apos;);</div><div class=\"line\">console.log(instance3.hobby)//[&quot;coding&quot;, &quot;running&quot;]</div><div class=\"line\">console.log(instance4.hobby)//[&quot;coding&quot;, &quot;running&quot;]</div></pre></td></tr></table></figure>\n<h3 id=\"寄生组合式继承\"><a href=\"#寄生组合式继承\" class=\"headerlink\" title=\"寄生组合式继承\"></a>寄生组合式继承</h3><blockquote>\n<p>最理想的继承方式</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\">function inheritProtoType(subType, superType) &#123;</div><div class=\"line\">    var prototype = Object.create(superType.prototype);</div><div class=\"line\">    prototype.constructor = subType;</div><div class=\"line\">    //子类的原型指向了父类的原型, 当在父类的原型上添加新方法时, 子类也能够调用</div><div class=\"line\">    subType.prototype = prototype;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">function SuperType(name) &#123;</div><div class=\"line\">    this.name = name;</div><div class=\"line\">    this.colors = [&quot;red&quot;];</div><div class=\"line\">&#125;</div><div class=\"line\">function SubType(name, age) &#123;</div><div class=\"line\">    //这里让父类的属性成为自己的副本</div><div class=\"line\">    SuperType.call(this, name);</div><div class=\"line\">    this.age = age;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">inheritProtoType(SubType, SuperType);</div><div class=\"line\">SubType.prototype.sayAge = function() &#123;</div><div class=\"line\">    console.log(this.age);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var instance1 = new SubType(&apos;hello&apos;, 1)</div><div class=\"line\">var instance2 = new SubType(&apos;world&apos;, 2)</div><div class=\"line\">instance1.colors.push(&quot;green&quot;);</div><div class=\"line\">instance1.colors;//[&quot;red&quot;, &quot;green&quot;]</div><div class=\"line\">instance2.colors;//[&quot;red&quot;]</div><div class=\"line\"></div><div class=\"line\">SuperType.prototype.sayName = function() &#123;</div><div class=\"line\">    console.log(this.name);</div><div class=\"line\">&#125;</div><div class=\"line\">instance1.sayName()//&quot;hello&quot;</div><div class=\"line\">instance2.sayName()//&quot;world&quot;</div></pre></td></tr></table></figure>\n"}