{"tags":[{"name":"You Don't Know JS","permalink":"http://blog.hellolc.com/tags/You-Don-t-Know-JS/","url":"/async/tags/You Don't Know JS.json","count":5}],"categories":[],"url":"/async/posts/2017/12/30/ProgramPerformance.json","date":1514621199000,"path":{"year":2017,"month":12,"day":30,"name":"ProgramPerformance"},"title":"Performance","permalink":"http://blog.hellolc.com/2017/12/30/ProgramPerformance/","content":"<h2 id=\"Web-Worker\"><a href=\"#Web-Worker\" class=\"headerlink\" title=\"Web Worker\"></a>Web Worker</h2><blockquote>\n<p>JavaScript是一门单线程语言, 我们可以通过浏览器的<code>Work</code>, 启动多线程来提高性能来处理io密集型计算, 大数据处理等; 但是主进程和子线程是隔离的, 只能通过监听事件和postMessage的方式进行传递消息</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">//在主线程启动线程 注意有跨域问题 而且必须是js可执行脚本</div><div class=\"line\">var w1 = new Worker( &quot;http://127.0.0.1:8080/test.js&quot; );</div><div class=\"line\">//监听事件, 就可以收到子线程的发送消息</div><div class=\"line\">w1.addEventListener(&quot;message&quot;, function(e) &#123;</div><div class=\"line\">    console.log(&quot;main process receive: &quot;, e.data)</div><div class=\"line\">&#125;)</div><div class=\"line\">//对子线程发送信息</div><div class=\"line\">w1.postMessage(&quot;hello world&quot;)</div><div class=\"line\"></div><div class=\"line\">// test.js</div><div class=\"line\">console.log(&quot;test.js....&quot;, navigator, location, JSON)</div><div class=\"line\">addEventListener( &quot;message&quot;, function(evt)&#123;</div><div class=\"line\">    // evt.data</div><div class=\"line\">    console.log(&quot;receive: &quot;, evt.data)</div><div class=\"line\">    postMessage( &quot;message has received&quot; );</div><div class=\"line\">&#125; );</div><div class=\"line\">importScripts(&quot;test2.js&quot;)</div></pre></td></tr></table></figure>\n<h3 id=\"Work-中可以使用如下全局变量\"><a href=\"#Work-中可以使用如下全局变量\" class=\"headerlink\" title=\"Work 中可以使用如下全局变量\"></a>Work 中可以使用如下全局变量</h3><ul>\n<li>navigator</li>\n<li>location</li>\n<li>JSON</li>\n<li>importScripts //同步阻塞引入其他脚本</li>\n</ul>\n<h3 id=\"Shared-Workers\"><a href=\"#Shared-Workers\" class=\"headerlink\" title=\"Shared Workers\"></a>Shared Workers</h3><p>通浏览器同时打开多个tab(同一个页面), 就会同时打开多个work, 此时我们可以用共享work来减少性能资源消耗<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">var w1 = new SharedWorker( &quot;http://127.0.0.1:8080/mySharedWorker.js&quot; );</div><div class=\"line\"></div><div class=\"line\">// 通过port对象作为唯一标识</div><div class=\"line\">w1.port.addEventListener( &quot;message&quot;, handleMessages );</div><div class=\"line\">w1.port.postMessage( &quot;something cool&quot; );</div><div class=\"line\"></div><div class=\"line\">//port connect initialized</div><div class=\"line\">w1.port.start();</div></pre></td></tr></table></figure></p>\n<p>在shared worker 内部给来的请求分配一个端口<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">// inside the mySharedWorker.js</div><div class=\"line\">addEventListener(&quot;connect&quot;, function (event) &#123;</div><div class=\"line\">    //分配端口给这个链接</div><div class=\"line\">    var port = event.ports[0];</div><div class=\"line\"></div><div class=\"line\">    port.addEventListener(&quot;message&quot;, function (event) &#123;</div><div class=\"line\">        // ....</div><div class=\"line\">        port.postMessage( .. );</div><div class=\"line\">    &#125;)</div><div class=\"line\"></div><div class=\"line\">    // initialize the port connection</div><div class=\"line\">    port.start();</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<h2 id=\"SIMD\"><a href=\"#SIMD\" class=\"headerlink\" title=\"SIMD\"></a>SIMD</h2><p>SIMD 打算把 CPU 级的并行数学运算映射到 JavaScript API，以获得高性能的数据并行运 算，比如在大数据集上的数字处理。 现在还在研发中, 也许会在es7出现</p>\n<h2 id=\"asm-js\"><a href=\"#asm-js\" class=\"headerlink\" title=\"asm.js\"></a>asm.js</h2><p>asm.js 优化了垃圾收集和强制类型转换等部分, 所以适合数学运算(如游戏中的图形处理)</p>\n<p><a href=\"http://asmjs.org/spec/latest/\" target=\"_blank\" rel=\"external\">asm 代码风格</a><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\"><span class=\"meta\">    \"use asm\"</span></div><div class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"number\">45</span>;</div><div class=\"line\">    <span class=\"keyword\">var</span> b = a | <span class=\"number\">0</span>; <span class=\"comment\">//因为js是32位的, 但现在的计算机一般都是64位的, 通过`| 0`后, 计算机知道这是32位的变量, 减少了对高位的追踪计算</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">var</span> heap = <span class=\"keyword\">new</span> <span class=\"built_in\">ArrayBuffer</span>( <span class=\"number\">0x10000</span> ); <span class=\"comment\">// 从堆里申请64k内存</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n"}