{"tags":[{"name":"ReactNative","permalink":"http://blog.hellolc.com/tags/ReactNative/","url":"/async/tags/ReactNative.json","count":2},{"name":"算法","permalink":"http://blog.hellolc.com/tags/算法/","url":"/async/tags/算法.json","count":2}],"categories":[],"url":"/async/posts/2017/02/18/Virtual DOM.json","date":1487420994000,"path":{"year":2017,"month":2,"day":18,"name":"Virtual DOM"},"title":"Virtual DOM","permalink":"http://blog.hellolc.com/2017/02/18/Virtual DOM/","content":"<h3 id=\"为什么要使用Vitrul-DOM\"><a href=\"#为什么要使用Vitrul-DOM\" class=\"headerlink\" title=\"为什么要使用Vitrul DOM\"></a>为什么要使用Vitrul DOM</h3><ul>\n<li>因为原生dom自带很多属性, 直接操作dom是非常笨重的, 性能效率非常低</li>\n</ul>\n<h3 id=\"Vitrul-DOM-原理\"><a href=\"#Vitrul-DOM-原理\" class=\"headerlink\" title=\"Vitrul DOM 原理\"></a>Vitrul DOM 原理</h3><ul>\n<li><p>因为原生dom过于笨重, 初始化了很多属性, 我们可以将原生dom用js对象来表示, 这个对象里只保存这个dom独有的属性, 省略了很多其他默认的属性</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">&lt;ul id=<span class=\"string\">'list'</span>&gt;</div><div class=\"line\">  &lt;li <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">'item'</span>&gt;Item <span class=\"number\">1</span>&lt;<span class=\"regexp\">/li&gt;</span></div><div class=\"line\"><span class=\"regexp\">  &lt;li class='item'&gt;Item 2&lt;/</span>li&gt;</div><div class=\"line\">  &lt;li <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">'item'</span>&gt;Item <span class=\"number\">3</span>&lt;<span class=\"regexp\">/li&gt;</span></div><div class=\"line\"><span class=\"regexp\">&lt;/u</span>l&gt;</div><div class=\"line\"><span class=\"comment\">//上面的js表示如下</span></div><div class=\"line\"><span class=\"keyword\">var</span> element = &#123;</div><div class=\"line\">  tagName: <span class=\"string\">'ul'</span>, <span class=\"comment\">// 节点标签名</span></div><div class=\"line\">  props: &#123; <span class=\"comment\">// DOM的属性，用一个对象存储键值对</span></div><div class=\"line\">    id: <span class=\"string\">'list'</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  children: [ <span class=\"comment\">// 该节点的子节点</span></div><div class=\"line\">    &#123;<span class=\"attr\">tagName</span>: <span class=\"string\">'li'</span>, <span class=\"attr\">props</span>: &#123;<span class=\"attr\">class</span>: <span class=\"string\">'item'</span>&#125;, <span class=\"attr\">children</span>: [<span class=\"string\">\"Item 1\"</span>]&#125;,</div><div class=\"line\">    &#123;<span class=\"attr\">tagName</span>: <span class=\"string\">'li'</span>, <span class=\"attr\">props</span>: &#123;<span class=\"attr\">class</span>: <span class=\"string\">'item'</span>&#125;, <span class=\"attr\">children</span>: [<span class=\"string\">\"Item 2\"</span>]&#125;,</div><div class=\"line\">    &#123;<span class=\"attr\">tagName</span>: <span class=\"string\">'li'</span>, <span class=\"attr\">props</span>: &#123;<span class=\"attr\">class</span>: <span class=\"string\">'item'</span>&#125;, <span class=\"attr\">children</span>: [<span class=\"string\">\"Item 3\"</span>]&#125;,</div><div class=\"line\">  ]</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>Virturl Dom 会把旧dom和新dom, 用js对象生成两棵树进行比较之间的差异</p>\n</li>\n<li>正如你所预料的，比较两棵DOM树的差异是 Virtual DOM 算法最核心的部分，这也是所谓的 Virtual DOM 的 diff 算法。两个树的完全的 diff 算法是一个时间复杂度为 O(n^3) 的问题。但是在前端当中，你很少会跨越层级地移动DOM元素。所以 Virtual DOM 只会对同一个层级的元素进行对比</li>\n<li>在比较过程, 记录每个节点的差异, 比如是节点元素类型变换了, 还是增删改了属性值等等</li>\n<li>最后对有变化的dom进行操作</li>\n</ul>\n<h3 id=\"如果dom只是重新排序了-利用上面的方法-性能也会很差\"><a href=\"#如果dom只是重新排序了-利用上面的方法-性能也会很差\" class=\"headerlink\" title=\"如果dom只是重新排序了? 利用上面的方法, 性能也会很差\"></a>如果dom只是重新排序了? 利用上面的方法, 性能也会很差</h3><ul>\n<li>这个问题抽象出来其实是字符串的最小编辑距离问题（Edition Distance），最常见的解决算法是 Levenshtein Distance，通过动态规划求解，时间复杂度为 O(M * N)。但是我们并不需要真的达到最小的操作，我们只需要优化一些比较常见的移动情况，牺牲一定DOM操作，让算法时间复杂度达到线性的（O(max(M, N))。具体算法细节比较多，这里不累述，有兴趣可以参考<a href=\"https://github.com/livoras/list-diff/blob/master/lib/diff.js\" target=\"_blank\" rel=\"external\">代码</a></li>\n</ul>\n<h3 id=\"为什么组件上要加上唯一的key标识\"><a href=\"#为什么组件上要加上唯一的key标识\" class=\"headerlink\" title=\"为什么组件上要加上唯一的key标识\"></a>为什么组件上要加上唯一的key标识</h3><ul>\n<li>因为tagName是可重复的，不能用这个来进行对比。所以需要给子节点加上唯一标识key，列表对比的时候，使用key进行对比，这样才能复用老的 DOM 树上的节点</li>\n</ul>\n<h3 id=\"参考学习\"><a href=\"#参考学习\" class=\"headerlink\" title=\"参考学习\"></a>参考学习</h3><ul>\n<li><a href=\"https://github.com/livoras/blog/issues/13\" target=\"_blank\" rel=\"external\">戴嘉华: 深度剖析：如何实现一个 Virtual DOM 算法</a></li>\n</ul>\n"}