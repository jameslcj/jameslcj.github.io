{"tags":[{"name":"You Don't Know JS","permalink":"http://blog.hellolc.com/tags/You-Don-t-Know-JS/","url":"/async/tags/You Don't Know JS.json","count":5}],"categories":[],"url":"/async/posts/2017/10/20/Natives.json","date":1508464395000,"path":{"year":2017,"month":10,"day":20,"name":"Natives"},"title":"Natives","permalink":"http://blog.hellolc.com/2017/10/20/Natives/","content":"<h2 id=\"Array\"><a href=\"#Array\" class=\"headerlink\" title=\"Array\"></a>Array</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Array(1, 2, 3);// [1, 2, 3]</span><br><span class=\"line\">Array(1, 2, 3);// [1, 2, 3]</span><br><span class=\"line\">[1, 2, 3];//[1, 2, 3]</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>以上是3种, 初始化数组的方式</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arr = new Array(3);</span><br><span class=\"line\">arr.length;//3</span><br><span class=\"line\">arr;//[empty x 3]</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>以上是一个奇怪的现象, 当我们给数组初始化时, 只传递一个数值时, 它不是初始化一个数组包含这个值, 而是初始化了长度为这个值的数组</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = new Array( 3 );//[empty x 3]</span><br><span class=\"line\">var b = [undefined, undefined, undefined ];//[undefined, undefined, undefined ]</span><br><span class=\"line\">var c = [];</span><br><span class=\"line\">c.length = 3; //[empty x 3]</span><br><span class=\"line\">var d = [, , ,]; //[empty x 3]</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>以上数组, 看似好像都是3个位置的数组, 但其实他们的值不全一样, 请看下面</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a.map(function(v, key)&#123; return key; &#125;); // [ undefined x 3 ]</span><br><span class=\"line\">b.map(function(v, key)&#123; return key; &#125;); // [ 0, 1, 2 ]</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>以上, 我们发现a居然没有key值, 所以以后要undefined填充的数组使用b的方式声明</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = Array.apply( null, &#123; length: 3 &#125; );</span><br><span class=\"line\">a; // [ undefined, undefined, undefined ]</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>以上是快速获取由undefined填充的数组</p>\n<p>总结: 我们应该尽量避免使用对象形式创建数组, 应该使用 <code>var arr = []</code> 这种字面量形式</p>\n</blockquote>\n<h2 id=\"Object-Function-and-RegExp\"><a href=\"#Object-Function-and-RegExp\" class=\"headerlink\" title=\"Object(..), Function(..), and RegExp(..)\"></a>Object(..), Function(..), and RegExp(..)</h2><blockquote>\n<p>字面量的/正则表达式/比 <code>new RegExp</code>方式性能会好很多, 因为js引擎会对其进行提前编译和缓存</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function isThisCool(vals,fn,rx) &#123;</span><br><span class=\"line\">    vals = vals || Array.prototype;</span><br><span class=\"line\">    fn = fn || Function.prototype;</span><br><span class=\"line\">    rx = rx || RegExp.prototype;</span><br><span class=\"line\">    return rx.test(</span><br><span class=\"line\">        vals.map( fn ).join( &quot;&quot; )</span><br><span class=\"line\">\t); </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">isThisCool();       // true</span><br><span class=\"line\"></span><br><span class=\"line\">isThisCool(</span><br><span class=\"line\">        [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;],</span><br><span class=\"line\">\t\tfunction(v)&#123; return v.toUpperCase(); &#125;,</span><br><span class=\"line\">\t\t/D/</span><br><span class=\"line\">\t\t);// false</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>如上, 是一种初始化类似的方式, 比<code>[], function(){},  /(?:)/</code>在性能上会好一点, 但是尽量避免有修改属性的操作, 因为那样有可能影响到元素属性, 导致bug</p>\n</blockquote>\n"}