{"tags":[{"name":"深入React技术栈","permalink":"http://blog.hellolc.com,http://www.wjcun.com/tags/深入React技术栈/","url":"/async/tags/深入React技术栈.json","count":2}],"categories":[],"url":"/async/posts/2017/10/11/漫谈React.json","date":1507683677000,"path":{"year":2017,"month":10,"day":11,"name":"漫谈React"},"title":"漫谈React","permalink":"http://blog.hellolc.com,http://www.wjcun.com/2017/10/11/漫谈React/","content":"<h2 id=\"事件系统\"><a href=\"#事件系统\" class=\"headerlink\" title=\"事件系统\"></a>事件系统</h2><h3 id=\"事件委派\"><a href=\"#事件委派\" class=\"headerlink\" title=\"事件委派\"></a>事件委派</h3><blockquote>\n<p>它并不会把事件处理函数直接绑定到 真实的节点上，而是把所有事件绑定到结构的最外层，使用一个统一的事件监听器，这个事件监 听器上维持了一个映射来保存所有组件内部的事件监听和处理函数</p>\n</blockquote>\n<h3 id=\"在React中使用原生事件\"><a href=\"#在React中使用原生事件\" class=\"headerlink\" title=\"在React中使用原生事件\"></a>在React中使用原生事件</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class NativeEventDemo extends Component &#123; </span><br><span class=\"line\">\tcomponentDidMount() &#123;</span><br><span class=\"line\">\t\tthis.refs.button.addEventListener(&apos;click&apos;, e =&gt; &#123; this.handleClick(e);&#125;); </span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\thandleClick(e) &#123; </span><br><span class=\"line\">\t\tconsole.log(e);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcomponentWillUnmount() &#123; </span><br><span class=\"line\">\t\tthis.refs.button.removeEventListener(&apos;click&apos;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\trender() &#123;</span><br><span class=\"line\">\t\treturn &lt;button ref=&quot;button&quot;&gt;Test&lt;/button&gt;;</span><br><span class=\"line\">\t&#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"组件通信\"><a href=\"#组件通信\" class=\"headerlink\" title=\"组件通信\"></a>组件通信</h2><h3 id=\"跨级组件通信通信\"><a href=\"#跨级组件通信通信\" class=\"headerlink\" title=\"跨级组件通信通信\"></a>跨级组件通信通信</h3><blockquote>\n<p>父级组件申明<code>getChildContext</code>方法和<code>childContextTypes</code>对象属性, 子组件申明<code>contextTypes</code>再可以通过<code>this.context</code>跨级获取对应的属性, 类似全局变量的概念, 但是这样比较混乱, react不建议这样使用</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Parent extends Component &#123;</span><br><span class=\"line\">\tstatic childContextTypes = &#123;</span><br><span class=\"line\">\t    color: PropTypes.string,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tgetChildContext() &#123; </span><br><span class=\"line\">\t\treturn &#123;</span><br><span class=\"line\">\t\t\tcolor: &apos;red&apos;, </span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\trender() &#123;</span><br><span class=\"line\">\t\treturn &lt;Son /&gt;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class Son extends Component &#123;</span><br><span class=\"line\">\tstatic contextTypes = &#123;</span><br><span class=\"line\">\t    color: PropTypes.string,</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\trender() &#123;</span><br><span class=\"line\">\t\treturn &#123;this.context.color&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"没有嵌套关系的组件通信\"><a href=\"#没有嵌套关系的组件通信\" class=\"headerlink\" title=\"没有嵌套关系的组件通信\"></a>没有嵌套关系的组件通信</h3><blockquote>\n<p>通过<code>EventEmitter</code>对象</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; EventEmitter &#125; from &apos;events&apos;;</span><br><span class=\"line\">const emitter = new EventEmitter();</span><br><span class=\"line\">class App extends Component &#123;</span><br><span class=\"line\">  componentDidMount() &#123;</span><br><span class=\"line\">    this.btnClick = emitter.on(&apos;btnClick&apos;, (data) =&gt; &#123; </span><br><span class=\"line\">      console.log(data);</span><br><span class=\"line\">      alert(data)</span><br><span class=\"line\">    &#125;); </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  componentWillUnmount() &#123;</span><br><span class=\"line\">    emitter.removeListener(this.btnClick);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class OtherComp extends Component &#123;</span><br><span class=\"line\">\tconstructor(props) &#123;</span><br><span class=\"line\">    \tsuper(props);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tonClickEvent() &#123;</span><br><span class=\"line\">\t    emitter.emit(&apos;btnClick&apos;, &apos;click...&apos;)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\trender() &#123;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\treturn &lt;button onClick=&#123;this.onClickEvent.bind(this)&#125;&gt;按钮&lt;/button&gt;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"高阶组件\"><a href=\"#高阶组件\" class=\"headerlink\" title=\"高阶组件\"></a>高阶组件</h2><h3 id=\"属性代理\"><a href=\"#属性代理\" class=\"headerlink\" title=\"属性代理\"></a>属性代理</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import React, &#123; Component &#125; from &apos;React&apos;;</span><br><span class=\"line\">const MyContainer = (WrappedComponent) =&gt; </span><br><span class=\"line\">\tclass extends Component &#123;</span><br><span class=\"line\">\trender() &#123;</span><br><span class=\"line\">\t\tconst newProps = &#123;</span><br><span class=\"line\">\t\t\ttext: newText, </span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t\treturn &lt;WrappedComponent &#123;...this.props&#125; &#123;...newProps&#125; /&gt;; </span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import React, &#123; Component &#125; from &apos;React&apos;;</span><br><span class=\"line\">const MyContainer = (WrappedComponent) =&gt;</span><br><span class=\"line\">\tclass extends Component &#123;</span><br><span class=\"line\">\t\tconstructor(props) &#123; </span><br><span class=\"line\">\t\t\tsuper(props); </span><br><span class=\"line\">\t\t\tthis.state = &#123;</span><br><span class=\"line\">\t\t  \t\tname: &apos;&apos;,</span><br><span class=\"line\">\t\t  \t&#125;;</span><br><span class=\"line\">\t\t\tthis.onNameChange = this.onNameChange.bind(this); </span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tonNameChange(event) &#123; </span><br><span class=\"line\">\t\t\tthis.setState(&#123;</span><br><span class=\"line\">\t\t\t\tname: event.target.value, </span><br><span class=\"line\">\t\t\t&#125;)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\trender() &#123;</span><br><span class=\"line\">\t\t\tconst newProps = &#123;</span><br><span class=\"line\">\t\t\t\tname: &#123;</span><br><span class=\"line\">\t\t\t\t\tvalue: this.state.name,</span><br><span class=\"line\">\t\t\t\t\tonChange: this.onNameChange,</span><br><span class=\"line\">\t\t\t\t&#125;, </span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\treturn &lt;WrappedComponent &#123;...this.props&#125; &#123;...newProps&#125; /&gt;; </span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@MyContainer</span><br><span class=\"line\">class MyComponent extends Component &#123;</span><br><span class=\"line\">\trender() &#123;</span><br><span class=\"line\">\t\treturn &lt;input name=&quot;name&quot; &#123;...this.props.name&#125; /&gt;;</span><br><span class=\"line\">\t&#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>通过以上的封装，我们就得到了一个被控制的 input 组件。</p>\n</blockquote>\n<h3 id=\"反向代理\"><a href=\"#反向代理\" class=\"headerlink\" title=\"反向代理\"></a>反向代理</h3><blockquote>\n<p>高阶组件集成传递进来的组件WrappedComponent, 然后通过super去反向调用</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const MyContainer = (WrappedComponent) =&gt; </span><br><span class=\"line\">\tclass extends WrappedComponent &#123;</span><br><span class=\"line\">\t\trender() &#123;</span><br><span class=\"line\">\t\t\treturn super.render();</span><br><span class=\"line\">\t\t&#125; </span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"组件性能优化\"><a href=\"#组件性能优化\" class=\"headerlink\" title=\"组件性能优化\"></a>组件性能优化</h2><h3 id=\"PureRender\"><a href=\"#PureRender\" class=\"headerlink\" title=\"PureRender\"></a>PureRender</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Account style=&#123;&#123; color: &apos;black&apos; &#125;&#125; /&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">//优化为如下</span><br><span class=\"line\"></span><br><span class=\"line\">const defaultStyle = &#123;&#123;color: &apos;black&apos;&#125;&#125;;</span><br><span class=\"line\">&lt;Account style=&#123;this.props.style || defaultStyle&#125; /&gt;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>如上, 我们知道，每次调用 React 组件其实都会重新创建组件。就算传入的数组或对象的值没有改变, 但它引用的地址改变, 因此对象和数组类型的数据, 应该用一个变量传入</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class NameItem extends Component &#123; </span><br><span class=\"line\">\trender() &#123;</span><br><span class=\"line\">\t\t//翻译成jsx为: &lt;Item children=&#123;React.createElement(&apos;span&apos;, &#123;&#125;, &apos;Arcthur&apos;)&#125;/&gt;</span><br><span class=\"line\">\t\treturn ( &lt;Item&gt;</span><br><span class=\"line\">\t\t\t&lt;span&gt;Arcthur&lt;/span&gt; &lt;Item/&gt;</span><br><span class=\"line\">\t\t )</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">import PureRenderMixin from &apos;react-addons-pure-render-mixin&apos;;</span><br><span class=\"line\">class NameItem extends Component &#123;</span><br><span class=\"line\">\tconstructor(props) &#123;</span><br><span class=\"line\">\t\tsuper(props);</span><br><span class=\"line\">\t\tthis.shouldComponentUpdate = PureRenderMixin.shouldComponentUpdate.bind(this); </span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\trender() &#123; </span><br><span class=\"line\">\t\treturn ( &lt;Item&gt;</span><br><span class=\"line\">\t\t\t&lt;span&gt;Arcthur&lt;/span&gt; &lt;/Item&gt;</span><br><span class=\"line\">\t\t); </span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>如上, Item 组件不论什么情况下都会重新渲染。那么，怎么避免 Item 组件的重复渲染呢? 很简单，我们给 NameItem 设置 PureRender</p>\n</blockquote>\n<h3 id=\"Immutable\"><a href=\"#Immutable\" class=\"headerlink\" title=\"Immutable\"></a>Immutable</h3><blockquote>\n<p>Immutable提供了很多类似es6工具方法, 它最大的亮点是提供了Map(对象), List(数据)这2个方法, 它可以得到不会被改变的对象和数组, 就可以防止数据被在某些黑盒里修改</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let a = Map(&#123;</span><br><span class=\"line\">\tselect: &apos;users&apos;,</span><br><span class=\"line\">\tfilter: Map(&#123; name: &apos;Cam&apos; &#125;),</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">let b = a.set(&apos;select&apos;, &apos;people&apos;);</span><br><span class=\"line\">a === b // false</span><br><span class=\"line\"></span><br><span class=\"line\">let map1 = Immutable.Map(&#123;a:1, b:1, c:1&#125;); </span><br><span class=\"line\">let map2 = Immutable.Map(&#123;a:1, b:1, c:1&#125;); </span><br><span class=\"line\">map1 === map2; // =&gt; false</span><br><span class=\"line\">Immutable.is(map1, map2); // =&gt; true</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>以上为Immutable的map简单用法, Immutable.is 比较的是两个对象的 hashCode 或 valueOf(对于 JavaScript 对象)。由于 Immutable 内部使用了 trie 数据结构来存储，只要两个对象的 hashCode 相等，值就是一样的。 这样的算法避免了深度遍历比较，因此性能非常好。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import React, &#123; Component &#125; from &apos;react&apos;; </span><br><span class=\"line\">import &#123; is &#125; from &apos;immutable&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">class App extends Component &#123; </span><br><span class=\"line\">\tshouldComponentUpdate(nextProps, nextState) &#123;</span><br><span class=\"line\">\t\tconst thisProps = this.props || &#123;&#125;;</span><br><span class=\"line\">\t\tconst thisState = this.state || &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tif (Object.keys(thisProps).length !== Object.keys(nextProps).length || Object.keys(thisState).length !== Object.keys(nextState).length) &#123;</span><br><span class=\"line\">\t\t\treturn true; </span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tfor (const key in nextProps) &#123;</span><br><span class=\"line\">\t\t\tif (nextProps.hasOwnProperty(key) &amp;&amp; !is(thisProps[key], nextProps[key])) &#123; </span><br><span class=\"line\">\t\t\t\treturn true;</span><br><span class=\"line\">\t\t\t&#125; </span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tfor (const key in nextState) &#123;</span><br><span class=\"line\">\t\t\tif (nextState.hasOwnProperty(key) &amp;&amp; !is(thisState[key], nextState[key])) &#123; </span><br><span class=\"line\">\t\t\t\treturn true;</span><br><span class=\"line\">\t\t\t&#125; </span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\treturn false; </span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>如上优化shouldComponentUpdate, Immutable.js提供了简洁、高效的判断数据是否变化的方法，只需 === 和 is 比较就能知 道是否需要执行 render，而这个操作几乎零成本，所以可以极大提高性能</p>\n</blockquote>\n<h3 id=\"key\"><a href=\"#key\" class=\"headerlink\" title=\"key\"></a>key</h3><blockquote>\n<p>我们迭代渲染数组时, 如果不给组件设置key或是设置了相同的key会有警告, 但是设置的key, 尽量根据组件自身属性而产生的唯一性key, 比如id, 尽量避免使用数组的key, 这样效率会很低, 因为所有组件基本都会重新渲染</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import React from &apos;react&apos;;</span><br><span class=\"line\">import createFragment from &apos;react-addons-create-fragment&apos;;</span><br><span class=\"line\">function Rank(&#123; first, second &#125;) &#123; </span><br><span class=\"line\">\tconst children = createFragment(&#123;</span><br><span class=\"line\">\t\tfirst: first,</span><br><span class=\"line\">\t\tsecond: second, </span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">\treturn ( &lt;ul&gt;&#123;children&#125; &lt;/ul&gt;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>关于 key，我们还需要知道的一种情况是，有两个子组件需要渲染的时候，我们没法给它们<br>设 key。这时需要用到 React 插件 createFragment 来解决, 如上</p>\n</blockquote>\n<h3 id=\"react-addons-perf-性能检测工具\"><a href=\"#react-addons-perf-性能检测工具\" class=\"headerlink\" title=\"react-addons-perf 性能检测工具\"></a>react-addons-perf 性能检测工具</h3><blockquote>\n<p>通过 Perf.start() 和 Perf.stop() 两个 API 设置 开始和结束的状态来作分析</p>\n</blockquote>\n<ul>\n<li>Perf.printInclusive(measurements):所有阶段的时间。 </li>\n<li>Perf.printExclusive(measurements):不包含挂载组件的时间，即初始化 props、state，调用 componentWillMount 和 componentDidMount 方法的时间等。</li>\n<li>Perf.printWasted(measurements):监测渲染的内容保持不变的组件(可以查看哪些组件<br>没有被 shouldComponentUpdate 命中)。</li>\n</ul>\n"}