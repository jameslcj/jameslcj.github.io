{"tags":[{"name":"You Don't Know JS","permalink":"http://blog.hellolc.com/tags/You-Don-t-Know-JS/","url":"/async/tags/You Don't Know JS.json","count":5}],"categories":[],"url":"/async/posts/2017/10/22/Coercion.json","date":1508653706000,"path":{"year":2017,"month":10,"day":22,"name":"Coercion"},"title":"Coercion","permalink":"http://blog.hellolc.com/2017/10/22/Coercion/","content":"<h2 id=\"Abstract-Value-Operations\"><a href=\"#Abstract-Value-Operations\" class=\"headerlink\" title=\"Abstract Value Operations\"></a>Abstract Value Operations</h2><h3 id=\"JSON-stringify\"><a href=\"#JSON-stringify\" class=\"headerlink\" title=\"JSON.stringify\"></a>JSON.stringify</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">JSON.stringify( undefined ); //&quot;undefined&quot;</div><div class=\"line\">JSON.stringify( function()&#123;&#125; ); //&quot;undefined&quot;</div><div class=\"line\">JSON.stringify( null ); //&quot;null&quot;</div><div class=\"line\">JSON.stringify(</div><div class=\"line\">   [1,undefined,function()&#123;&#125;,4]</div><div class=\"line\">); // &quot;[1,null,null,4]&quot;</div><div class=\"line\">JSON.stringify(</div><div class=\"line\">   &#123; a:2, b:function()&#123;&#125; &#125;</div><div class=\"line\">);// &quot;&#123;&quot;a&quot;:2&#125;&quot;</div></pre></td></tr></table></figure>\n<blockquote>\n<p>从上可以看出, 不同类型的值在不同类型中, <code>JSON.stringify</code>的结果表现形式也不一样, 在数组的<code>undefined</code>, <code>function</code>会被转换成<code>null</code>, 在对象里值为<code>undefined, function</code>的属性会被过滤掉</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">var a = &#123; </div><div class=\"line\">\tb: 42,</div><div class=\"line\">\tc: o,</div><div class=\"line\">    d: function()&#123;&#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">// create a circular reference inside `a`</div><div class=\"line\">o.e = a;</div><div class=\"line\"></div><div class=\"line\">// would throw an error on the circular reference</div><div class=\"line\">// JSON.stringify( a );</div><div class=\"line\"></div><div class=\"line\">// define a custom JSON value serialization</div><div class=\"line\">a.toJSON = function() &#123;</div><div class=\"line\">    // only include the `b` property for serialization</div><div class=\"line\">    return &#123; b: this.b &#125;;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">JSON.stringify( a ); // &quot;&#123;&quot;b&quot;:42&#125;&quot;</div></pre></td></tr></table></figure>\n<blockquote>\n<p>如果我们对象引用了自身, 再执行<code>JSON.stringify</code>时会报异常, 我们可以给这个对象定义一个<code>toJSON</code>的方法, 返回一个默认对象, 来避免这种情况</p>\n</blockquote>\n<h2 id=\"Explicit-Coercion\"><a href=\"#Explicit-Coercion\" class=\"headerlink\" title=\"Explicit Coercion\"></a>Explicit Coercion</h2><h3 id=\"ToNumber\"><a href=\"#ToNumber\" class=\"headerlink\" title=\"ToNumber\"></a>ToNumber</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">Nubmer(true);//1</div><div class=\"line\">Nubmer(false);//0</div><div class=\"line\">Nubmer(undefined);//NaN</div><div class=\"line\">Nubmer(null);//0</div><div class=\"line\">Nubmer(&quot;&quot;);//0</div><div class=\"line\">Nubmer(&quot;false&quot;);//NaN</div><div class=\"line\">Nubmer([]);//0</div><div class=\"line\">Nubmer([&quot;&quot;]);//0</div><div class=\"line\">Nubmer([&quot;&quot;, &quot;&quot;]);//NaN</div><div class=\"line\">Nubmer(&#123;&#125;);//NaN</div><div class=\"line\">Nubmer(function()&#123;&#125;);//NaN</div><div class=\"line\"></div><div class=\"line\">var num1 = true + 1; // 1 + 1 = 2</div><div class=\"line\">var num2 = false + 1; //0 + 1 = 1</div><div class=\"line\">var num3 = undefined + 1; //NaN + 1 = NaN</div><div class=\"line\">var num4 = null + 1; // 0 + 1 = 1</div></pre></td></tr></table></figure>\n<blockquote>\n<p>综上可知, <code>true, false, undefined, null</code>在数学计算中, 强转后的数值不一, 格外需要注意的是<code>undefined</code>和非空字符串会被转换为<code>NaN</code></p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"> var a = &#123;</div><div class=\"line\">        valueOf: function()&#123;</div><div class=\"line\">            return &quot;42&quot;;</div><div class=\"line\">        &#125;,</div><div class=\"line\">        toString: function()&#123;</div><div class=\"line\">            return &quot;4221&quot;;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">    var b = &#123;</div><div class=\"line\">        toString: function()&#123;</div><div class=\"line\">            return &quot;42&quot;;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">var c = [4,2];</div><div class=\"line\">c.toString = function()&#123;</div><div class=\"line\">    return this.join( &quot;&quot; ); // &quot;42&quot;</div><div class=\"line\">&#125;;</div><div class=\"line\">Number( a ); //42</div><div class=\"line\">Number( b ); //42</div><div class=\"line\">Number( c ); //42</div><div class=\"line\">a + &apos;&apos;;//42</div></pre></td></tr></table></figure>\n<blockquote>\n<p>如果定义了<code>valueOf</code>, <code>toString</code>, 在强转的时候, 会优先调用<code>valueOf</code>, 如果没有<code>valueOf</code>, 再调用<code>toString</code></p>\n</blockquote>\n<h3 id=\"ToBoolean\"><a href=\"#ToBoolean\" class=\"headerlink\" title=\"ToBoolean\"></a>ToBoolean</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">Boolean(&quot;&quot;);//false</div><div class=\"line\">Boolean(NaN);//false</div><div class=\"line\">Boolean(undefined);//false</div><div class=\"line\">Boolean(null);//false</div><div class=\"line\">Boolean(0);//false</div><div class=\"line\">Boolean(-0);//false</div><div class=\"line\"></div><div class=\"line\">Boolean(new Boolean( false ));//true</div><div class=\"line\">Boolean(new Number( 0 ));//true</div><div class=\"line\">Boolean(new String( &quot;&quot; ));//true</div><div class=\"line\">Boolean(&quot;0&quot;);//true</div><div class=\"line\">Boolean([]);//true</div><div class=\"line\">Boolean(&#123;&#125;);//true</div></pre></td></tr></table></figure>\n<blockquote>\n<p>只有上面几种情况会返回<code>false</code>, 其余都会返回<code>true</code></p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Boolean(document.all)//false</div></pre></td></tr></table></figure>\n<blockquote>\n<p><code>Boolean(document.all)</code>居然返回false, 似乎和上面的结论矛盾, 其实是因为历史原因, <code>document.all</code>其实已经被废弃, 但是又为了兼容有些代码, 浏览器又不能把他删除, 但又不想让<code>if(document.all){}</code>这样的代码执行, 因此让<code>Boolean(document.all)</code>为<code>false</code>, 即使<code>document.all</code>返回的是一个类数组</p>\n</blockquote>\n<h3 id=\"Explicitly-Parsing-Numeric-Strings\"><a href=\"#Explicitly-Parsing-Numeric-Strings\" class=\"headerlink\" title=\"Explicitly: Parsing Numeric Strings\"></a>Explicitly: Parsing Numeric Strings</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">var a = &quot;42&quot;;</div><div class=\"line\">var b = &quot;42px&quot;;</div><div class=\"line\">Number( a );    // 42</div><div class=\"line\">parseInt( a );  // 42</div><div class=\"line\">Number( b );    // NaN</div><div class=\"line\">parseInt( b );  // 42</div></pre></td></tr></table></figure>\n<blockquote>\n<p><code>parseInt</code>只要解析是值, 第一个是数字就能解析, 否则就返回<code>NaN</code></p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">parseInt(1/0, 19);//18</div><div class=\"line\">parseInt( 0.000008 );// 0   (&quot;0&quot; from &quot;0.000008&quot;)</div><div class=\"line\">parseInt( 0.0000008 );// 8   (&quot;8&quot; from &quot;8e-7&quot;)</div><div class=\"line\">parseInt( false, 16 );// 250 (&quot;fa&quot; from &quot;false&quot;)</div><div class=\"line\">parseInt( parseInt, 16 );// 15  (&quot;f&quot; from &quot;function..&quot;)</div><div class=\"line\">parseInt( &quot;0x10&quot; );// 16</div><div class=\"line\">parseInt( &quot;103&quot;, 2 ); // 2</div></pre></td></tr></table></figure>\n<blockquote>\n<p><code>parseInt()</code>的一些奇怪现象</p>\n</blockquote>\n<h2 id=\"Implicit-Coercion\"><a href=\"#Implicit-Coercion\" class=\"headerlink\" title=\"Implicit Coercion\"></a>Implicit Coercion</h2><h3 id=\"Implicitly-Strings-lt-–-gt-Numbers\"><a href=\"#Implicitly-Strings-lt-–-gt-Numbers\" class=\"headerlink\" title=\"Implicitly: Strings &lt;–&gt; Numbers\"></a>Implicitly: Strings &lt;–&gt; Numbers</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">var a = [1,2];</div><div class=\"line\">var b = [3,4];</div><div class=\"line\">a + b; // &quot;1,23,4&quot;</div><div class=\"line\"></div><div class=\"line\">&#123;&#125; + [];//0 这里&#123;&#125;其实不是表示空对象, 而是表示一个块作用域, 因此没有任务作用, 所以 +[] 转换为数字为0</div><div class=\"line\">[] + &#123;&#125;;//&quot;[object Object]&quot; 这里&#123;&#125;表示对象被强转成了字符串</div></pre></td></tr></table></figure>\n<blockquote>\n<p>以上是一些比较奇怪的现象</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"> var a = &#123;</div><div class=\"line\">        valueOf: function() &#123; return 42; &#125;,</div><div class=\"line\">        toString: function() &#123; return 4; &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">a + &quot;&quot;; // &quot;42&quot;</div><div class=\"line\">String( a );    // &quot;4&quot;</div></pre></td></tr></table></figure>\n<blockquote>\n<p>以上两者转换是有区别的, <code>a + &quot;&quot;</code>这种形式会优先调用<code>valueOf</code>方法, 而<code>String()</code>直接调用<code>toString</code>方法</p>\n</blockquote>\n<h2 id=\"Loose-Equals-Versus-Strict-Equals\"><a href=\"#Loose-Equals-Versus-Strict-Equals\" class=\"headerlink\" title=\"Loose Equals Versus Strict Equals\"></a>Loose Equals Versus Strict Equals</h2><blockquote>\n<p>我们经常会说<code>==</code>表示检测两者的值否是相等, <code>===</code>表示检测两者的值相等的同时再检测类型是否相同, 这种说法不是完全正确, 正确理解应该是, <code>==</code>会将两值转换成同一类型再进行比较, 而<code>===</code>不会将两值类型做转换而直接进行比较<br>当一个<code>String</code>类型和一个<code>Number</code>类型进行<code>==</code>比较, <code>String</code>类型会转换为<code>Number</code></p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">var num = 42;</div><div class=\"line\">num == true;//false ==&gt; 42 == Number(true) ==&gt; 42 == 1</div><div class=\"line\">num == false;//false ==&gt; 42 == Number(false) ==&gt; 42 == 0</div></pre></td></tr></table></figure>\n<blockquote>\n<p>上面的比较结果居然都是<code>false</code>, 据我们上面分析得知, 42被转换为布尔值为<code>true</code>, 但实际上, 当一个<code>Number</code>类型和一个<code>Boolean</code>类型做比较时, <code>Boolean</code>类型会被转换成<code>Number</code>类型</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">var str = &quot;42&quot;</div><div class=\"line\">num == true;//false ==&gt; Number(&quot;42&quot;) == Number(true) ==&gt; 42 == 1</div><div class=\"line\">num == false;//false ==&gt; Number(&quot;42&quot;) == Number(false) ==&gt; 42 == 0</div></pre></td></tr></table></figure>\n<blockquote>\n<p>当2个非数字类型的变量进行比较时, 两者都会转换成<code>Number</code>类型再进行比较</p>\n</blockquote>\n<h3 id=\"Comparing-nulls-to-unde-neds\"><a href=\"#Comparing-nulls-to-unde-neds\" class=\"headerlink\" title=\"Comparing: nulls to unde neds\"></a>Comparing: nulls to unde neds</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">null == undefined;//true</div></pre></td></tr></table></figure>\n<blockquote>\n<p><code>null</code>和<code>undefined</code>这两者与其他类型比较都是返回<code>false</code>, 只有以上情况, 会返回<code>true</code>,</p>\n</blockquote>\n<h3 id=\"Comparing-objects-to-nonobjects\"><a href=\"#Comparing-objects-to-nonobjects\" class=\"headerlink\" title=\"Comparing: objects to nonobjects\"></a>Comparing: objects to nonobjects</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">var a = 42;</div><div class=\"line\">var b = [42];</div><div class=\"line\">a == b; //true</div></pre></td></tr></table></figure>\n<blockquote>\n<p>以上结果得知, 所有对象类型与原始标量类型做比较时, 对象类型都会被转换成原始标量类型再进行比较</p>\n</blockquote>\n<h3 id=\"Edge-Cases\"><a href=\"#Edge-Cases\" class=\"headerlink\" title=\"Edge Cases\"></a>Edge Cases</h3><blockquote>\n<p>一些比较奇怪的bug</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">Number.prototype.valueOf = function() &#123;</div><div class=\"line\">    return 3;</div><div class=\"line\">&#125;;</div><div class=\"line\">new Nubmer( 2 ); //2 </div><div class=\"line\">new Number( 2 ) == 3;   // true</div><div class=\"line\">new Number( 2 ) == 2;   // false</div></pre></td></tr></table></figure>\n<blockquote>\n<p>上面是比较奇怪的<code>bug</code>, 返回是2, 但是与2不相等</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">var i = 2;</div><div class=\"line\">    Number.prototype.valueOf = function() &#123;</div><div class=\"line\">        return i++;</div><div class=\"line\">&#125;;</div><div class=\"line\">var a = new Number( 42 );</div><div class=\"line\">if (a == 2 &amp;&amp; a == 3) &#123;</div><div class=\"line\">    console.log( &quot;Yep, this happened.&quot; );</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<blockquote>\n<p>以上<code>if</code>结果是<code>true</code></p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">&quot;0&quot; == false; //true 两者类型不同, 都会转换成Number类型再进行比较</div><div class=\"line\">&quot;0&quot; == &quot;&quot;; //false 都是字符串类型, 不进行转换直接比较</div><div class=\"line\"></div><div class=\"line\">false == []; //true //转换成数字类型再进行比较</div><div class=\"line\">false == &#123;&#125;; //false //转换成数字类型再进行比较</div><div class=\"line\"></div><div class=\"line\">&quot;&quot; == []; //true</div><div class=\"line\">&quot;&quot; == &#123;&#125;; //false</div><div class=\"line\"></div><div class=\"line\">0 == []; //true</div><div class=\"line\">0 == &#123;&#125;; //false</div></pre></td></tr></table></figure>\n<blockquote>\n<p>上面为何 <code>[]``{}</code> 比较结果不一样呢? 因为<code>Number([]) === 0</code> <code>Number({})</code>结果为NaN; <code>String([]) === &#39;&#39;</code> <code>String({}) === [object Object]</code></p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[] == ![]; //true</div></pre></td></tr></table></figure>\n<blockquote>\n<p>非常奇怪, 上面结果是<code>true</code>, 因为上面的转换规则如下 <code>==&gt; [] == false ==&gt; ==&gt; Number([]) == Number(false) ==&gt; 0 == 0 ==&gt; true</code></p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">2 == [2];       // true  Number([2]) ==&gt; 2</div><div class=\"line\">&quot;&quot; == [null];   // true  String([null]) ==&gt; &quot;&quot;</div></pre></td></tr></table></figure>\n<blockquote>\n<p>上面, 只要按照对象类型与原始类型比较时, 对象类型会被转换成原始类型再进行比较</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">0 == &quot;\\n&quot; //==&gt; 0 == Number(&quot;\\n&quot;) ==&gt; 0 == 0</div></pre></td></tr></table></figure>\n<h3 id=\"Abstract-Relational-Comparison\"><a href=\"#Abstract-Relational-Comparison\" class=\"headerlink\" title=\"Abstract Relational Comparison\"></a>Abstract Relational Comparison</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[42] &lt; [&quot;43&quot;]; //true</div><div class=\"line\">[&quot;42&quot;] &lt; [&quot;043&quot;]; //false</div></pre></td></tr></table></figure>\n<blockquote>\n<p>上面第一条是可以理解的, 第二条是因为两者都是字符串数组, 所以就转换成字符串比较, 字符串比较是按位比较的, 他们各自的第一位分别是4与0, 所有<code>[&quot;42&quot;] &gt; [&quot;043&quot;]</code></p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">var a = &#123; b: 42 &#125;;</div><div class=\"line\">var b = &#123; b: 43 &#125;;</div><div class=\"line\"></div><div class=\"line\">a &lt; b;  // false</div><div class=\"line\">a == b; // false</div><div class=\"line\">a &gt; b;  // false</div><div class=\"line\"></div><div class=\"line\">a &lt;= b; // true</div><div class=\"line\">a &gt;= b; // true</div></pre></td></tr></table></figure>\n<blockquote>\n<p>上面真是个奇怪的现象, 为什么会这样呢? 因为js判断<code>a &lt;= b</code>的时候其实是转换成<code>!(a&gt;b)</code> 判断<code>a&gt;=b</code>的时候其实是转换成<code>!(a&lt;b)</code></p>\n</blockquote>\n"}