{"tags":[{"name":"javaScript高级程序设计笔记","permalink":"http://blog.hellolc.com/tags/javaScript高级程序设计笔记/","url":"/async/tags/javaScript高级程序设计笔记.json","count":5}],"categories":[],"url":"/async/posts/2017/07/06/函数表达式.json","date":1499304371000,"path":{"year":2017,"month":7,"day":6,"name":"函数表达式"},"title":"函数表达式","permalink":"http://blog.hellolc.com/2017/07/06/函数表达式/","content":"<h2 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">function funcName(arg0, arg1, arg2)&#123;&#125;</div><div class=\"line\">console.log(funcName.name)//funcName(函数的名字)</div><div class=\"line\">console.log(funcName.length)//3(参数个数)</div></pre></td></tr></table></figure>\n<h3 id=\"函数表达式与函数声明的区别\"><a href=\"#函数表达式与函数声明的区别\" class=\"headerlink\" title=\"函数表达式与函数声明的区别\"></a>函数表达式与函数声明的区别</h3><blockquote>\n<p>函数表达式必须先赋值才有对应的值, 而函数声明可以在函数名前调用;<br>函数表达式可以是匿名函数, 而函数声明必须有函数名</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">console.log(func)//function func()&#123;&#125;</div><div class=\"line\">//函数表达式</div><div class=\"line\">function func()&#123;&#125;</div><div class=\"line\"></div><div class=\"line\">console.log(fn)//undefined</div><div class=\"line\">//函数表达式</div><div class=\"line\">var fn = function()&#123;&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h2><blockquote>\n<p>在递归时, 可以用arguments.callee代替自身函数名, 这样就可以解耦, 随意修改函数名</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">function factorial(num) &#123;</div><div class=\"line\">  if (num &lt;= 1) &#123;</div><div class=\"line\">    return 1;</div><div class=\"line\">  &#125;</div><div class=\"line\">  return num * arguments.callee(num-1);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h2><blockquote>\n<p>闭包会携带包含它的函数作用域, 所以它所占的内存逼其他函数多, 建议尽量少用; V8引擎会尝试回收被闭包占用的内存;<br>个人理解: 没有闭包这东西, 无非就是作用域导致的现象, 也可以说任何函数其实都是闭包</p>\n</blockquote>\n<h3 id=\"闭包与变量\"><a href=\"#闭包与变量\" class=\"headerlink\" title=\"闭包与变量\"></a>闭包与变量</h3><blockquote>\n<p>本来有一个需求是, 调用<code>createFunctions()[1]()</code>函数就返回对应的索引的值, 也就是1, 但是结果却是10; 因为这个函数返回的是一个闭包;<br>这个闭包又要返回i, 但在它自身的作用域里无法找到这个变量, 它就会去作用域链上查找, 但是作用域链上的i, 最循环结束后, 已变成10了; 所以调用任何一个闭包,<br>都是指向同一个作用域链上的i, 其值为10;</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">function createFunctions() &#123;</div><div class=\"line\">    var result = [];</div><div class=\"line\"></div><div class=\"line\">    for (var i=0; i &lt; 10; i++) &#123;</div><div class=\"line\">        result[i] = function() &#123;</div><div class=\"line\">            return i;</div><div class=\"line\">        &#125;;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    return result;</div><div class=\"line\">&#125;</div><div class=\"line\">createFunctions()[1]()//10</div></pre></td></tr></table></figure>\n<blockquote>\n<p>可以修改为如下, 将i通过函数的方式传递进去, 那么num就是i的副本, 它的改变不所i而改变;<br>因此当调用<code>createFunctions()[1]()</code>时, 需要返回num, 再其自身作用域里没有num, 就往上一级作用域里查找,<br>正好可以找到num, 并返回, 其值也是和外层循环时传递进来的值一样;</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">function createFunctions() &#123;</div><div class=\"line\">    var result = [];</div><div class=\"line\"></div><div class=\"line\">    for (var i=0; i &lt; 10; i++) &#123;</div><div class=\"line\">        result[i] = (function(num) &#123;</div><div class=\"line\">          return function() &#123;</div><div class=\"line\">              return num;</div><div class=\"line\">          &#125;</div><div class=\"line\">        &#125;)(i)</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    return result;</div><div class=\"line\">&#125;</div><div class=\"line\">createFunctions()[1]()//1</div></pre></td></tr></table></figure>\n<h3 id=\"内存泄露\"><a href=\"#内存泄露\" class=\"headerlink\" title=\"内存泄露\"></a>内存泄露</h3><blockquote>\n<p>在ie9以前的浏览器dom节点是使用计数引用的方式管理回收内存, 因此不合理利用闭包会导致内存泄露;<br>下面这个函数onclick的闭包函数, 引用了elemnt.id, 所以导致element无法被回收</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">function assignHandler() &#123;</div><div class=\"line\">    var element = document.getElementById(&quot;someElement&quot;);</div><div class=\"line\">    element.onclick = function() &#123;</div><div class=\"line\">        alert(element.id)</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<blockquote>\n<p>可以将代码改成如下, 避免泄露, 首先建立一个element.id的副本, 再最后将element设置为null</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">function assignHandler() &#123;</div><div class=\"line\">    var element = document.getElementById(&quot;someElement&quot;);</div><div class=\"line\">    var id = element.id;</div><div class=\"line\">    element.onclick = function() &#123;</div><div class=\"line\">        alert(id)</div><div class=\"line\">    &#125;;</div><div class=\"line\">    element = null;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"关于this\"><a href=\"#关于this\" class=\"headerlink\" title=\"关于this\"></a>关于this</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">var name = &quot;the window&quot;</div><div class=\"line\">var object  = &#123;</div><div class=\"line\">    name: &quot;my object&quot;,</div><div class=\"line\">    getName: function() &#123;</div><div class=\"line\">        return this.name;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">object.getName();//&quot;my object&quot;</div><div class=\"line\">(object.getName)();//&quot;my object&quot;</div><div class=\"line\">(object.getName = object.getName)();//&quot;the window&quot;</div></pre></td></tr></table></figure>\n<h2 id=\"模仿块级作用域\"><a href=\"#模仿块级作用域\" class=\"headerlink\" title=\"模仿块级作用域\"></a>模仿块级作用域</h2><blockquote>\n<p>javaScript没有强类型语言中的块级作用域, 但可以利用匿名函数自执行来模拟;<br>当一个函数声明被放在一个双扩里时, 就变成了表达式, 再添加双括号调用, 就会执行此函数;<br>在函数内声明的变量, 也不会影响到外部, 实现块级作用域的效果.</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">(function() &#123;</div><div class=\"line\">  for (var i = 0; i &lt; 10; i++) &#123;</div><div class=\"line\">    console.log(i);</div><div class=\"line\">  &#125;</div><div class=\"line\">  &#125;)()</div><div class=\"line\">console.log(i)//ERROR</div></pre></td></tr></table></figure>\n<h2 id=\"私有变量\"><a href=\"#私有变量\" class=\"headerlink\" title=\"私有变量\"></a>私有变量</h2><h3 id=\"静态私有变量\"><a href=\"#静态私有变量\" class=\"headerlink\" title=\"静态私有变量\"></a>静态私有变量</h3><blockquote>\n<p>JavaScript中的静态私有变量, 也是通过闭包模拟实现的;<br>先用匿名函数自执行, 建立一个全新作用域, 这样变量就不能被外部直接访问,<br>然后将构造函数挂载到外面的变量上暴露出去, 在其原型链上再添加获取和修改私有变量的方法,<br>因为闭包的原因, 即使构造函数被实例化多次, 他们还是公用同一个<code>name</code>值来实现静态效果.<br>如果想通过原型对象上添加方法修改私有变量, 这样也无法实现, 因为在外面添加的原型方法,<br>无法访问到里面作用域的变量.</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">var Person = null;</div><div class=\"line\">(function() &#123;</div><div class=\"line\">  var name = &quot;&quot;;</div><div class=\"line\">  Person = function(value) &#123;</div><div class=\"line\">    name = value;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  Person.prototype.setName = function(value) &#123;</div><div class=\"line\">    name = value;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  Person.prototype.getName = function() &#123;</div><div class=\"line\">    return name;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)()</div><div class=\"line\">var p1 = new Person(&quot;hello&quot;);</div><div class=\"line\">p1.getName();//&quot;hello&quot;</div><div class=\"line\">var p2 = new Person(&quot;world&quot;);</div><div class=\"line\">p1.getName();//&quot;world&quot;</div><div class=\"line\">p2.getName();//&quot;world&quot;</div><div class=\"line\"></div><div class=\"line\">Person.prototype.getName2 = function() &#123;</div><div class=\"line\">  return name;</div><div class=\"line\">&#125;</div><div class=\"line\">p1.getName2();//&quot;&quot;</div></pre></td></tr></table></figure>\n<h3 id=\"模块模式-单列模式\"><a href=\"#模块模式-单列模式\" class=\"headerlink\" title=\"模块模式(单列模式)\"></a>模块模式(单列模式)</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">var singleton = function() &#123;</div><div class=\"line\">  //私有变量</div><div class=\"line\">  var privateVar = 1;</div><div class=\"line\">  function privateFunc() &#123;</div><div class=\"line\">    return privateVar;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  //用户自定义的对象</div><div class=\"line\">  var obj = new customObj();</div><div class=\"line\"></div><div class=\"line\">  //共有变量</div><div class=\"line\">  obj.publicVar = true;</div><div class=\"line\">  //共有方法</div><div class=\"line\">  obj.publicMethod = function() &#123;</div><div class=\"line\">    privateVar ++;</div><div class=\"line\">    return privateFunc();</div><div class=\"line\">  &#125;</div><div class=\"line\">  return obj;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n"}